// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/v2/apis/common/v1"
)

type ClusterAgentDeploymentCustomizationAppendTolerationsInitParameters struct {

	// The toleration effect. Default: \"NoSchedule\".
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// The toleration key.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The toleration operator.
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// The number of seconds a pod will stay bound to a node with a matching taint.
	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`

	// Rancher agent env var value.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ClusterAgentDeploymentCustomizationAppendTolerationsObservation struct {

	// The toleration effect. Default: \"NoSchedule\".
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// The toleration key.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The toleration operator.
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// The number of seconds a pod will stay bound to a node with a matching taint.
	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`

	// Rancher agent env var value.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ClusterAgentDeploymentCustomizationAppendTolerationsParameters struct {

	// The toleration effect. Default: \"NoSchedule\".
	// +kubebuilder:validation:Optional
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// The toleration key.
	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`

	// The toleration operator.
	// +kubebuilder:validation:Optional
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// The number of seconds a pod will stay bound to a node with a matching taint.
	// +kubebuilder:validation:Optional
	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`

	// Rancher agent env var value.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ClusterAgentDeploymentCustomizationOverrideResourceRequirementsInitParameters struct {

	// The maximum CPU limit for agent.
	// The maximum CPU limit for agent
	CPULimit *string `json:"cpuLimit,omitempty" tf:"cpu_limit,omitempty"`

	// The minimum CPU required for agent.
	// The minimum CPU required for agent
	CPURequest *string `json:"cpuRequest,omitempty" tf:"cpu_request,omitempty"`

	// The maximum memory limit for agent.
	// The maximum memory limit for agent
	MemoryLimit *string `json:"memoryLimit,omitempty" tf:"memory_limit,omitempty"`

	// The minimum memory required for agent.
	// The minimum memory required for agent
	MemoryRequest *string `json:"memoryRequest,omitempty" tf:"memory_request,omitempty"`
}

type ClusterAgentDeploymentCustomizationOverrideResourceRequirementsObservation struct {

	// The maximum CPU limit for agent.
	// The maximum CPU limit for agent
	CPULimit *string `json:"cpuLimit,omitempty" tf:"cpu_limit,omitempty"`

	// The minimum CPU required for agent.
	// The minimum CPU required for agent
	CPURequest *string `json:"cpuRequest,omitempty" tf:"cpu_request,omitempty"`

	// The maximum memory limit for agent.
	// The maximum memory limit for agent
	MemoryLimit *string `json:"memoryLimit,omitempty" tf:"memory_limit,omitempty"`

	// The minimum memory required for agent.
	// The minimum memory required for agent
	MemoryRequest *string `json:"memoryRequest,omitempty" tf:"memory_request,omitempty"`
}

type ClusterAgentDeploymentCustomizationOverrideResourceRequirementsParameters struct {

	// The maximum CPU limit for agent.
	// The maximum CPU limit for agent
	// +kubebuilder:validation:Optional
	CPULimit *string `json:"cpuLimit,omitempty" tf:"cpu_limit,omitempty"`

	// The minimum CPU required for agent.
	// The minimum CPU required for agent
	// +kubebuilder:validation:Optional
	CPURequest *string `json:"cpuRequest,omitempty" tf:"cpu_request,omitempty"`

	// The maximum memory limit for agent.
	// The maximum memory limit for agent
	// +kubebuilder:validation:Optional
	MemoryLimit *string `json:"memoryLimit,omitempty" tf:"memory_limit,omitempty"`

	// The minimum memory required for agent.
	// The minimum memory required for agent
	// +kubebuilder:validation:Optional
	MemoryRequest *string `json:"memoryRequest,omitempty" tf:"memory_request,omitempty"`
}

type ClusterAgentDeploymentCustomizationSchedulingCustomizationInitParameters struct {

	// The definition of a Pod Disruption Budget deployed for the cluster agent
	// The Pod Disruption Budget created for the cattle cluster agent
	PodDisruptionBudget []SchedulingCustomizationPodDisruptionBudgetInitParameters `json:"podDisruptionBudget,omitempty" tf:"pod_disruption_budget,omitempty"`

	// The definition of a Priority Class deployed for the cluster agent
	// The Priority Class created for the cattle cluster agent
	PriorityClass []SchedulingCustomizationPriorityClassInitParameters `json:"priorityClass,omitempty" tf:"priority_class,omitempty"`
}

type ClusterAgentDeploymentCustomizationSchedulingCustomizationObservation struct {

	// The definition of a Pod Disruption Budget deployed for the cluster agent
	// The Pod Disruption Budget created for the cattle cluster agent
	PodDisruptionBudget []SchedulingCustomizationPodDisruptionBudgetObservation `json:"podDisruptionBudget,omitempty" tf:"pod_disruption_budget,omitempty"`

	// The definition of a Priority Class deployed for the cluster agent
	// The Priority Class created for the cattle cluster agent
	PriorityClass []SchedulingCustomizationPriorityClassObservation `json:"priorityClass,omitempty" tf:"priority_class,omitempty"`
}

type ClusterAgentDeploymentCustomizationSchedulingCustomizationParameters struct {

	// The definition of a Pod Disruption Budget deployed for the cluster agent
	// The Pod Disruption Budget created for the cattle cluster agent
	// +kubebuilder:validation:Optional
	PodDisruptionBudget []SchedulingCustomizationPodDisruptionBudgetParameters `json:"podDisruptionBudget,omitempty" tf:"pod_disruption_budget,omitempty"`

	// The definition of a Priority Class deployed for the cluster agent
	// The Priority Class created for the cattle cluster agent
	// +kubebuilder:validation:Optional
	PriorityClass []SchedulingCustomizationPriorityClassParameters `json:"priorityClass,omitempty" tf:"priority_class,omitempty"`
}

type ClusterV2AgentEnvVarsInitParameters struct {

	// The name of the cluster.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Rancher agent env var value.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ClusterV2AgentEnvVarsObservation struct {

	// The name of the cluster.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Rancher agent env var value.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ClusterV2AgentEnvVarsParameters struct {

	// The name of the cluster.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`

	// Rancher agent env var value.
	// +kubebuilder:validation:Optional
	Value *string `json:"value" tf:"value,omitempty"`
}

type ClusterV2ClusterAgentDeploymentCustomizationInitParameters struct {

	// A list of tolerations to be appended to the default tolerations.
	// User defined tolerations to append to agent
	AppendTolerations []ClusterAgentDeploymentCustomizationAppendTolerationsInitParameters `json:"appendTolerations,omitempty" tf:"append_tolerations,omitempty"`

	// Override affinity overrides the global default affinity setting.
	// User defined affinity to override default agent affinity
	OverrideAffinity *string `json:"overrideAffinity,omitempty" tf:"override_affinity,omitempty"`

	// Override resource requirements overrides the default value for requests and/or limits.
	// User defined resource requirements to set on the agent
	OverrideResourceRequirements []ClusterAgentDeploymentCustomizationOverrideResourceRequirementsInitParameters `json:"overrideResourceRequirements,omitempty" tf:"override_resource_requirements,omitempty"`

	// Supported in Rancher 2.11.0 and above. Defines the configuration of a Priority Class and or Pod Disruption Budget. Currently only supported in the cluster_agent_deployment_customization field, and requires the cattle_cluster_agent_scheduling_customization feature to be enabled.
	// User defined scheduling customization for the cattle cluster agent
	SchedulingCustomization []ClusterAgentDeploymentCustomizationSchedulingCustomizationInitParameters `json:"schedulingCustomization,omitempty" tf:"scheduling_customization,omitempty"`
}

type ClusterV2ClusterAgentDeploymentCustomizationObservation struct {

	// A list of tolerations to be appended to the default tolerations.
	// User defined tolerations to append to agent
	AppendTolerations []ClusterAgentDeploymentCustomizationAppendTolerationsObservation `json:"appendTolerations,omitempty" tf:"append_tolerations,omitempty"`

	// Override affinity overrides the global default affinity setting.
	// User defined affinity to override default agent affinity
	OverrideAffinity *string `json:"overrideAffinity,omitempty" tf:"override_affinity,omitempty"`

	// Override resource requirements overrides the default value for requests and/or limits.
	// User defined resource requirements to set on the agent
	OverrideResourceRequirements []ClusterAgentDeploymentCustomizationOverrideResourceRequirementsObservation `json:"overrideResourceRequirements,omitempty" tf:"override_resource_requirements,omitempty"`

	// Supported in Rancher 2.11.0 and above. Defines the configuration of a Priority Class and or Pod Disruption Budget. Currently only supported in the cluster_agent_deployment_customization field, and requires the cattle_cluster_agent_scheduling_customization feature to be enabled.
	// User defined scheduling customization for the cattle cluster agent
	SchedulingCustomization []ClusterAgentDeploymentCustomizationSchedulingCustomizationObservation `json:"schedulingCustomization,omitempty" tf:"scheduling_customization,omitempty"`
}

type ClusterV2ClusterAgentDeploymentCustomizationParameters struct {

	// A list of tolerations to be appended to the default tolerations.
	// User defined tolerations to append to agent
	// +kubebuilder:validation:Optional
	AppendTolerations []ClusterAgentDeploymentCustomizationAppendTolerationsParameters `json:"appendTolerations,omitempty" tf:"append_tolerations,omitempty"`

	// Override affinity overrides the global default affinity setting.
	// User defined affinity to override default agent affinity
	// +kubebuilder:validation:Optional
	OverrideAffinity *string `json:"overrideAffinity,omitempty" tf:"override_affinity,omitempty"`

	// Override resource requirements overrides the default value for requests and/or limits.
	// User defined resource requirements to set on the agent
	// +kubebuilder:validation:Optional
	OverrideResourceRequirements []ClusterAgentDeploymentCustomizationOverrideResourceRequirementsParameters `json:"overrideResourceRequirements,omitempty" tf:"override_resource_requirements,omitempty"`

	// Supported in Rancher 2.11.0 and above. Defines the configuration of a Priority Class and or Pod Disruption Budget. Currently only supported in the cluster_agent_deployment_customization field, and requires the cattle_cluster_agent_scheduling_customization feature to be enabled.
	// User defined scheduling customization for the cattle cluster agent
	// +kubebuilder:validation:Optional
	SchedulingCustomization []ClusterAgentDeploymentCustomizationSchedulingCustomizationParameters `json:"schedulingCustomization,omitempty" tf:"scheduling_customization,omitempty"`
}

type ClusterV2ClusterRegistrationTokenInitParameters struct {
}

type ClusterV2ClusterRegistrationTokenObservation struct {

	// Annotations for the Cluster.
	// +mapType=granular
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// (Computed, string) Cluster ID.
	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	// (Computed, string) Command to execute in an imported k8s cluster.
	Command *string `json:"command,omitempty" tf:"command,omitempty"`

	// (Computed, string) The ID of the resource.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (Computed, string) Insecure command to execute in an imported k8s cluster.
	InsecureCommand *string `json:"insecureCommand,omitempty" tf:"insecure_command,omitempty"`

	// (Computed, string) Insecure node command to execute in an imported k8s cluster.
	InsecureNodeCommand *string `json:"insecureNodeCommand,omitempty" tf:"insecure_node_command,omitempty"`

	// (Computed, string) Insecure windows command to execute in an imported k8s cluster.
	InsecureWindowsNodeCommand *string `json:"insecureWindowsNodeCommand,omitempty" tf:"insecure_windows_node_command,omitempty"`

	// Labels for the Cluster.
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// (Computed, string) K8s manifest url to execute with kubectl to import an existing k8s cluster.
	ManifestURL *string `json:"manifestUrl,omitempty" tf:"manifest_url,omitempty"`

	// The name of the cluster.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Computed, string) Node command to execute in Linux nodes for custom k8s cluster.
	NodeCommand *string `json:"nodeCommand,omitempty" tf:"node_command,omitempty"`

	// (Computed, string) Token for cluster registration token object.
	Token *string `json:"token,omitempty" tf:"token,omitempty"`

	// (Computed, string) Node command to execute in Windows nodes for custom k8s cluster.
	WindowsNodeCommand *string `json:"windowsNodeCommand,omitempty" tf:"windows_node_command,omitempty"`
}

type ClusterV2ClusterRegistrationTokenParameters struct {
}

type ClusterV2FleetAgentDeploymentCustomizationAppendTolerationsInitParameters struct {

	// The toleration effect. Default: \"NoSchedule\".
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// The toleration key.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The toleration operator.
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// The number of seconds a pod will stay bound to a node with a matching taint.
	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`

	// Rancher agent env var value.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ClusterV2FleetAgentDeploymentCustomizationAppendTolerationsObservation struct {

	// The toleration effect. Default: \"NoSchedule\".
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// The toleration key.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The toleration operator.
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// The number of seconds a pod will stay bound to a node with a matching taint.
	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`

	// Rancher agent env var value.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ClusterV2FleetAgentDeploymentCustomizationAppendTolerationsParameters struct {

	// The toleration effect. Default: \"NoSchedule\".
	// +kubebuilder:validation:Optional
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// The toleration key.
	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`

	// The toleration operator.
	// +kubebuilder:validation:Optional
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// The number of seconds a pod will stay bound to a node with a matching taint.
	// +kubebuilder:validation:Optional
	Seconds *float64 `json:"seconds,omitempty" tf:"seconds,omitempty"`

	// Rancher agent env var value.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ClusterV2FleetAgentDeploymentCustomizationInitParameters struct {

	// A list of tolerations to be appended to the default tolerations.
	// User defined tolerations to append to agent
	AppendTolerations []ClusterV2FleetAgentDeploymentCustomizationAppendTolerationsInitParameters `json:"appendTolerations,omitempty" tf:"append_tolerations,omitempty"`

	// Override affinity overrides the global default affinity setting.
	// User defined affinity to override default agent affinity
	OverrideAffinity *string `json:"overrideAffinity,omitempty" tf:"override_affinity,omitempty"`

	// Override resource requirements overrides the default value for requests and/or limits.
	// User defined resource requirements to set on the agent
	OverrideResourceRequirements []ClusterV2FleetAgentDeploymentCustomizationOverrideResourceRequirementsInitParameters `json:"overrideResourceRequirements,omitempty" tf:"override_resource_requirements,omitempty"`
}

type ClusterV2FleetAgentDeploymentCustomizationObservation struct {

	// A list of tolerations to be appended to the default tolerations.
	// User defined tolerations to append to agent
	AppendTolerations []ClusterV2FleetAgentDeploymentCustomizationAppendTolerationsObservation `json:"appendTolerations,omitempty" tf:"append_tolerations,omitempty"`

	// Override affinity overrides the global default affinity setting.
	// User defined affinity to override default agent affinity
	OverrideAffinity *string `json:"overrideAffinity,omitempty" tf:"override_affinity,omitempty"`

	// Override resource requirements overrides the default value for requests and/or limits.
	// User defined resource requirements to set on the agent
	OverrideResourceRequirements []ClusterV2FleetAgentDeploymentCustomizationOverrideResourceRequirementsObservation `json:"overrideResourceRequirements,omitempty" tf:"override_resource_requirements,omitempty"`
}

type ClusterV2FleetAgentDeploymentCustomizationOverrideResourceRequirementsInitParameters struct {

	// The maximum CPU limit for agent.
	// The maximum CPU limit for agent
	CPULimit *string `json:"cpuLimit,omitempty" tf:"cpu_limit,omitempty"`

	// The minimum CPU required for agent.
	// The minimum CPU required for agent
	CPURequest *string `json:"cpuRequest,omitempty" tf:"cpu_request,omitempty"`

	// The maximum memory limit for agent.
	// The maximum memory limit for agent
	MemoryLimit *string `json:"memoryLimit,omitempty" tf:"memory_limit,omitempty"`

	// The minimum memory required for agent.
	// The minimum memory required for agent
	MemoryRequest *string `json:"memoryRequest,omitempty" tf:"memory_request,omitempty"`
}

type ClusterV2FleetAgentDeploymentCustomizationOverrideResourceRequirementsObservation struct {

	// The maximum CPU limit for agent.
	// The maximum CPU limit for agent
	CPULimit *string `json:"cpuLimit,omitempty" tf:"cpu_limit,omitempty"`

	// The minimum CPU required for agent.
	// The minimum CPU required for agent
	CPURequest *string `json:"cpuRequest,omitempty" tf:"cpu_request,omitempty"`

	// The maximum memory limit for agent.
	// The maximum memory limit for agent
	MemoryLimit *string `json:"memoryLimit,omitempty" tf:"memory_limit,omitempty"`

	// The minimum memory required for agent.
	// The minimum memory required for agent
	MemoryRequest *string `json:"memoryRequest,omitempty" tf:"memory_request,omitempty"`
}

type ClusterV2FleetAgentDeploymentCustomizationOverrideResourceRequirementsParameters struct {

	// The maximum CPU limit for agent.
	// The maximum CPU limit for agent
	// +kubebuilder:validation:Optional
	CPULimit *string `json:"cpuLimit,omitempty" tf:"cpu_limit,omitempty"`

	// The minimum CPU required for agent.
	// The minimum CPU required for agent
	// +kubebuilder:validation:Optional
	CPURequest *string `json:"cpuRequest,omitempty" tf:"cpu_request,omitempty"`

	// The maximum memory limit for agent.
	// The maximum memory limit for agent
	// +kubebuilder:validation:Optional
	MemoryLimit *string `json:"memoryLimit,omitempty" tf:"memory_limit,omitempty"`

	// The minimum memory required for agent.
	// The minimum memory required for agent
	// +kubebuilder:validation:Optional
	MemoryRequest *string `json:"memoryRequest,omitempty" tf:"memory_request,omitempty"`
}

type ClusterV2FleetAgentDeploymentCustomizationParameters struct {

	// A list of tolerations to be appended to the default tolerations.
	// User defined tolerations to append to agent
	// +kubebuilder:validation:Optional
	AppendTolerations []ClusterV2FleetAgentDeploymentCustomizationAppendTolerationsParameters `json:"appendTolerations,omitempty" tf:"append_tolerations,omitempty"`

	// Override affinity overrides the global default affinity setting.
	// User defined affinity to override default agent affinity
	// +kubebuilder:validation:Optional
	OverrideAffinity *string `json:"overrideAffinity,omitempty" tf:"override_affinity,omitempty"`

	// Override resource requirements overrides the default value for requests and/or limits.
	// User defined resource requirements to set on the agent
	// +kubebuilder:validation:Optional
	OverrideResourceRequirements []ClusterV2FleetAgentDeploymentCustomizationOverrideResourceRequirementsParameters `json:"overrideResourceRequirements,omitempty" tf:"override_resource_requirements,omitempty"`
}

type ClusterV2InitParameters struct {

	// Agent env vars is a list of additional environment variables to be appended to the cattle-cluster-agent and fleet-agent deployment, and the plan for the system upgrade controller to upgrade nodes.
	// Cluster V2 default agent env vars
	AgentEnvVars []ClusterV2AgentEnvVarsInitParameters `json:"agentEnvVars,omitempty" tf:"agent_env_vars,omitempty"`

	// Annotations for the Cluster.
	// Annotations of the resource
	// +mapType=granular
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// Cloud credential secret name is the secret to be used when a cloud credential secret name is not specified at the machine pool level.
	// Cluster V2 cloud credential secret name
	CloudCredentialSecretName *string `json:"cloudCredentialSecretName,omitempty" tf:"cloud_credential_secret_name,omitempty"`

	// Cluster agent deployment customization specifies the additional tolerations, new affinity rules, and new resource requirements on the cattle-cluster-agent deployment. This argument is available in Rancher v2.7.5 and above.
	// Optional customization for cluster agent
	ClusterAgentDeploymentCustomization []ClusterV2ClusterAgentDeploymentCustomizationInitParameters `json:"clusterAgentDeploymentCustomization,omitempty" tf:"cluster_agent_deployment_customization,omitempty"`

	// Default cluster role for project members.
	// Cluster V2 default cluster role for project members
	DefaultClusterRoleForProjectMembers *string `json:"defaultClusterRoleForProjectMembers,omitempty" tf:"default_cluster_role_for_project_members,omitempty"`

	// The name of the pre-defined pod security admission configuration template to be applied to the cluster. Rancher admins (or those with the right permissions) can create, manage, and edit those templates. For more information, please refer to Rancher Documentation. The argument is available in Rancher v2.7.2 and above.
	// Cluster V2 default pod security admission configuration template name
	DefaultPodSecurityAdmissionConfigurationTemplateName *string `json:"defaultPodSecurityAdmissionConfigurationTemplateName,omitempty" tf:"default_pod_security_admission_configuration_template_name,omitempty"`

	// Enable k8s network policy on the cluster.
	// Enable k8s network policy
	EnableNetworkPolicy *bool `json:"enableNetworkPolicy,omitempty" tf:"enable_network_policy,omitempty"`

	// Fleet agent deployment customization specifies the additional tolerations, new affinity rules, and new resource requirements on the fleet-agent deployment. The argument is available in Rancher v2.7.5 and above.
	// Optional customization for fleet agent
	FleetAgentDeploymentCustomization []ClusterV2FleetAgentDeploymentCustomizationInitParameters `json:"fleetAgentDeploymentCustomization,omitempty" tf:"fleet_agent_deployment_customization,omitempty"`

	// Fleet namespace is the namespace where the cluster is to create in the local cluster. It is recommended to leave it as the default value.
	FleetNamespace *string `json:"fleetNamespace,omitempty" tf:"fleet_namespace,omitempty"`

	// The RKE2 or K3s version for the cluster.
	// Cluster V2 kubernetes version
	KubernetesVersion *string `json:"kubernetesVersion,omitempty" tf:"kubernetes_version,omitempty"`

	// Labels for the Cluster.
	// Labels of the resource
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// Local auth endpoint configures the Authorized Cluster Endpoint (ACE) which can be used to directly access the Kubernetes API server, without requiring communication through Rancher. For more information, please refer to Rancher Documentation.
	// Cluster V2 local auth endpoint
	LocalAuthEndpoint []LocalAuthEndpointInitParameters `json:"localAuthEndpoint,omitempty" tf:"local_auth_endpoint,omitempty"`

	// The name of the cluster.
	// Cluster V2 name
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The RKE configuration for the cluster.
	// Cluster V2 rke config
	RkeConfig []ClusterV2RkeConfigInitParameters `json:"rkeConfig,omitempty" tf:"rke_config,omitempty"`
}

type ClusterV2Observation struct {

	// Agent env vars is a list of additional environment variables to be appended to the cattle-cluster-agent and fleet-agent deployment, and the plan for the system upgrade controller to upgrade nodes.
	// Cluster V2 default agent env vars
	AgentEnvVars []ClusterV2AgentEnvVarsObservation `json:"agentEnvVars,omitempty" tf:"agent_env_vars,omitempty"`

	// Annotations for the Cluster.
	// Annotations of the resource
	// +mapType=granular
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// Cloud credential secret name is the secret to be used when a cloud credential secret name is not specified at the machine pool level.
	// Cluster V2 cloud credential secret name
	CloudCredentialSecretName *string `json:"cloudCredentialSecretName,omitempty" tf:"cloud_credential_secret_name,omitempty"`

	// Cluster agent deployment customization specifies the additional tolerations, new affinity rules, and new resource requirements on the cattle-cluster-agent deployment. This argument is available in Rancher v2.7.5 and above.
	// Optional customization for cluster agent
	ClusterAgentDeploymentCustomization []ClusterV2ClusterAgentDeploymentCustomizationObservation `json:"clusterAgentDeploymentCustomization,omitempty" tf:"cluster_agent_deployment_customization,omitempty"`

	// (Computed, string) Cluster v1 id for cluster v2. (e.g. to be used with rancher2_sync).
	ClusterV1ID *string `json:"clusterV1Id,omitempty" tf:"cluster_v1_id,omitempty"`

	// Default cluster role for project members.
	// Cluster V2 default cluster role for project members
	DefaultClusterRoleForProjectMembers *string `json:"defaultClusterRoleForProjectMembers,omitempty" tf:"default_cluster_role_for_project_members,omitempty"`

	// The name of the pre-defined pod security admission configuration template to be applied to the cluster. Rancher admins (or those with the right permissions) can create, manage, and edit those templates. For more information, please refer to Rancher Documentation. The argument is available in Rancher v2.7.2 and above.
	// Cluster V2 default pod security admission configuration template name
	DefaultPodSecurityAdmissionConfigurationTemplateName *string `json:"defaultPodSecurityAdmissionConfigurationTemplateName,omitempty" tf:"default_pod_security_admission_configuration_template_name,omitempty"`

	// Enable k8s network policy on the cluster.
	// Enable k8s network policy
	EnableNetworkPolicy *bool `json:"enableNetworkPolicy,omitempty" tf:"enable_network_policy,omitempty"`

	// Fleet agent deployment customization specifies the additional tolerations, new affinity rules, and new resource requirements on the fleet-agent deployment. The argument is available in Rancher v2.7.5 and above.
	// Optional customization for fleet agent
	FleetAgentDeploymentCustomization []ClusterV2FleetAgentDeploymentCustomizationObservation `json:"fleetAgentDeploymentCustomization,omitempty" tf:"fleet_agent_deployment_customization,omitempty"`

	// Fleet namespace is the namespace where the cluster is to create in the local cluster. It is recommended to leave it as the default value.
	FleetNamespace *string `json:"fleetNamespace,omitempty" tf:"fleet_namespace,omitempty"`

	// (Computed, string) The ID of the resource.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The RKE2 or K3s version for the cluster.
	// Cluster V2 kubernetes version
	KubernetesVersion *string `json:"kubernetesVersion,omitempty" tf:"kubernetes_version,omitempty"`

	// Labels for the Cluster.
	// Labels of the resource
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// Local auth endpoint configures the Authorized Cluster Endpoint (ACE) which can be used to directly access the Kubernetes API server, without requiring communication through Rancher. For more information, please refer to Rancher Documentation.
	// Cluster V2 local auth endpoint
	LocalAuthEndpoint []LocalAuthEndpointObservation `json:"localAuthEndpoint,omitempty" tf:"local_auth_endpoint,omitempty"`

	// The name of the cluster.
	// Cluster V2 name
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Computed, string) Cluster's k8s resource version.
	ResourceVersion *string `json:"resourceVersion,omitempty" tf:"resource_version,omitempty"`

	// The RKE configuration for the cluster.
	// Cluster V2 rke config
	RkeConfig []ClusterV2RkeConfigObservation `json:"rkeConfig,omitempty" tf:"rke_config,omitempty"`
}

type ClusterV2Parameters struct {

	// Agent env vars is a list of additional environment variables to be appended to the cattle-cluster-agent and fleet-agent deployment, and the plan for the system upgrade controller to upgrade nodes.
	// Cluster V2 default agent env vars
	// +kubebuilder:validation:Optional
	AgentEnvVars []ClusterV2AgentEnvVarsParameters `json:"agentEnvVars,omitempty" tf:"agent_env_vars,omitempty"`

	// Annotations for the Cluster.
	// Annotations of the resource
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// Cloud credential secret name is the secret to be used when a cloud credential secret name is not specified at the machine pool level.
	// Cluster V2 cloud credential secret name
	// +kubebuilder:validation:Optional
	CloudCredentialSecretName *string `json:"cloudCredentialSecretName,omitempty" tf:"cloud_credential_secret_name,omitempty"`

	// Cluster agent deployment customization specifies the additional tolerations, new affinity rules, and new resource requirements on the cattle-cluster-agent deployment. This argument is available in Rancher v2.7.5 and above.
	// Optional customization for cluster agent
	// +kubebuilder:validation:Optional
	ClusterAgentDeploymentCustomization []ClusterV2ClusterAgentDeploymentCustomizationParameters `json:"clusterAgentDeploymentCustomization,omitempty" tf:"cluster_agent_deployment_customization,omitempty"`

	// Default cluster role for project members.
	// Cluster V2 default cluster role for project members
	// +kubebuilder:validation:Optional
	DefaultClusterRoleForProjectMembers *string `json:"defaultClusterRoleForProjectMembers,omitempty" tf:"default_cluster_role_for_project_members,omitempty"`

	// The name of the pre-defined pod security admission configuration template to be applied to the cluster. Rancher admins (or those with the right permissions) can create, manage, and edit those templates. For more information, please refer to Rancher Documentation. The argument is available in Rancher v2.7.2 and above.
	// Cluster V2 default pod security admission configuration template name
	// +kubebuilder:validation:Optional
	DefaultPodSecurityAdmissionConfigurationTemplateName *string `json:"defaultPodSecurityAdmissionConfigurationTemplateName,omitempty" tf:"default_pod_security_admission_configuration_template_name,omitempty"`

	// Enable k8s network policy on the cluster.
	// Enable k8s network policy
	// +kubebuilder:validation:Optional
	EnableNetworkPolicy *bool `json:"enableNetworkPolicy,omitempty" tf:"enable_network_policy,omitempty"`

	// Fleet agent deployment customization specifies the additional tolerations, new affinity rules, and new resource requirements on the fleet-agent deployment. The argument is available in Rancher v2.7.5 and above.
	// Optional customization for fleet agent
	// +kubebuilder:validation:Optional
	FleetAgentDeploymentCustomization []ClusterV2FleetAgentDeploymentCustomizationParameters `json:"fleetAgentDeploymentCustomization,omitempty" tf:"fleet_agent_deployment_customization,omitempty"`

	// Fleet namespace is the namespace where the cluster is to create in the local cluster. It is recommended to leave it as the default value.
	// +kubebuilder:validation:Optional
	FleetNamespace *string `json:"fleetNamespace,omitempty" tf:"fleet_namespace,omitempty"`

	// The RKE2 or K3s version for the cluster.
	// Cluster V2 kubernetes version
	// +kubebuilder:validation:Optional
	KubernetesVersion *string `json:"kubernetesVersion,omitempty" tf:"kubernetes_version,omitempty"`

	// Labels for the Cluster.
	// Labels of the resource
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// Local auth endpoint configures the Authorized Cluster Endpoint (ACE) which can be used to directly access the Kubernetes API server, without requiring communication through Rancher. For more information, please refer to Rancher Documentation.
	// Cluster V2 local auth endpoint
	// +kubebuilder:validation:Optional
	LocalAuthEndpoint []LocalAuthEndpointParameters `json:"localAuthEndpoint,omitempty" tf:"local_auth_endpoint,omitempty"`

	// The name of the cluster.
	// Cluster V2 name
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The RKE configuration for the cluster.
	// Cluster V2 rke config
	// +kubebuilder:validation:Optional
	RkeConfig []ClusterV2RkeConfigParameters `json:"rkeConfig,omitempty" tf:"rke_config,omitempty"`
}

type ClusterV2RkeConfigInitParameters struct {

	// The value of the additional manifest is delivered to the path /var/lib/rancher/rke2/server/manifests/rancher/addons.yaml or /var/lib/rancher/k3s/server/manifests/rancher/addons.yaml on the control plane nodes.
	// Cluster V2 additional manifest
	AdditionalManifest *string `json:"additionalManifest,omitempty" tf:"additional_manifest,omitempty"`

	// The value for the system charts installed by the distribution. For more information about how RKE2 or K3s manage packaged components, please refer to RKE2 documentation or K3s documentation.
	// Cluster V2 chart values. It should be in YAML format
	ChartValues *string `json:"chartValues,omitempty" tf:"chart_values,omitempty"`

	// Data directory configuration for the kubernetes distro, system-agent, and provisioning resources.
	// Cluster V2 data directories
	DataDirectories []DataDirectoriesInitParameters `json:"dataDirectories,omitempty" tf:"data_directories,omitempty"`

	// Etcd configures the behavior of the automatic etcd snapshot feature.
	// Cluster V2 etcd
	Etcd []RkeConfigEtcdInitParameters `json:"etcd,omitempty" tf:"etcd,omitempty"`

	// Cluster V2 etcd snapshot create.
	// Cluster V2 etcd snapshot create
	EtcdSnapshotCreate []EtcdSnapshotCreateInitParameters `json:"etcdSnapshotCreate,omitempty" tf:"etcd_snapshot_create,omitempty"`

	// Cluster V2 etcd snapshot restore.
	// Cluster V2 etcd snapshot restore
	EtcdSnapshotRestore []EtcdSnapshotRestoreInitParameters `json:"etcdSnapshotRestore,omitempty" tf:"etcd_snapshot_restore,omitempty"`

	// Local auth endpoint configures the Authorized Cluster Endpoint (ACE) which can be used to directly access the Kubernetes API server, without requiring communication through Rancher. For more information, please refer to Rancher Documentation.
	// Cluster V2 local auth endpoint
	LocalAuthEndpoint []RkeConfigLocalAuthEndpointInitParameters `json:"localAuthEndpoint,omitempty" tf:"local_auth_endpoint,omitempty"`

	// Machine global config specifies the distribution-specified server configuration applied to all nodes. For the full list of server configurations, please refer to RKE2 server configuration or K3s server configuration.
	// Cluster V2 machine global config
	MachineGlobalConfig *string `json:"machineGlobalConfig,omitempty" tf:"machine_global_config,omitempty"`

	// Default values for machine pool configurations if unset
	MachinePoolDefaults []MachinePoolDefaultsInitParameters `json:"machinePoolDefaults,omitempty" tf:"machine_pool_defaults,omitempty"`

	// Cluster V2 machine pools.
	// Cluster V2 machine pools
	MachinePools []MachinePoolsInitParameters `json:"machinePools,omitempty" tf:"machine_pools,omitempty"`

	// Machine selector config is the same as machine_global_config except that a label selector can be specified with the configuration. The configuration will only be applied to nodes that match the provided label selector. The configuration from machine_selector_config takes precedence over the one from machine_global_config. This argument is available in Rancher v2.7.2 and later.
	// Cluster V2 machine selector config
	MachineSelectorConfig []MachineSelectorConfigInitParameters `json:"machineSelectorConfig,omitempty" tf:"machine_selector_config,omitempty"`

	// Machine selector files provide a means to deliver files to nodes so that the files can be in place before initiating RKE2/K3s server or agent processes. Please refer to Rancher documentation for RKE2 Cluster Configuration Reference and K3s Cluster Configuration Reference. This argument is available in Rancher v2.7.2 and later.
	// Cluster V2 machine selector files
	MachineSelectorFiles []MachineSelectorFilesInitParameters `json:"machineSelectorFiles,omitempty" tf:"machine_selector_files,omitempty"`

	// The networking stack used by the cluster.
	// Cluster V2 networking
	Networking []NetworkingInitParameters `json:"networking,omitempty" tf:"networking,omitempty"`

	// Docker registries from which the cluster pulls images.
	// Cluster V2 registries
	Registries []RegistriesInitParameters `json:"registries,omitempty" tf:"registries,omitempty"`

	// Cluster V2 certificate rotation.
	// Cluster V2 certificate rotation
	RotateCertificates []RotateCertificatesInitParameters `json:"rotateCertificates,omitempty" tf:"rotate_certificates,omitempty"`

	// Cluster upgrade strategy.
	// Cluster V2 upgrade strategy
	UpgradeStrategy []ClusterV2RkeConfigUpgradeStrategyInitParameters `json:"upgradeStrategy,omitempty" tf:"upgrade_strategy,omitempty"`
}

type ClusterV2RkeConfigObservation struct {

	// The value of the additional manifest is delivered to the path /var/lib/rancher/rke2/server/manifests/rancher/addons.yaml or /var/lib/rancher/k3s/server/manifests/rancher/addons.yaml on the control plane nodes.
	// Cluster V2 additional manifest
	AdditionalManifest *string `json:"additionalManifest,omitempty" tf:"additional_manifest,omitempty"`

	// The value for the system charts installed by the distribution. For more information about how RKE2 or K3s manage packaged components, please refer to RKE2 documentation or K3s documentation.
	// Cluster V2 chart values. It should be in YAML format
	ChartValues *string `json:"chartValues,omitempty" tf:"chart_values,omitempty"`

	// Data directory configuration for the kubernetes distro, system-agent, and provisioning resources.
	// Cluster V2 data directories
	DataDirectories []DataDirectoriesObservation `json:"dataDirectories,omitempty" tf:"data_directories,omitempty"`

	// Etcd configures the behavior of the automatic etcd snapshot feature.
	// Cluster V2 etcd
	Etcd []RkeConfigEtcdObservation `json:"etcd,omitempty" tf:"etcd,omitempty"`

	// Cluster V2 etcd snapshot create.
	// Cluster V2 etcd snapshot create
	EtcdSnapshotCreate []EtcdSnapshotCreateObservation `json:"etcdSnapshotCreate,omitempty" tf:"etcd_snapshot_create,omitempty"`

	// Cluster V2 etcd snapshot restore.
	// Cluster V2 etcd snapshot restore
	EtcdSnapshotRestore []EtcdSnapshotRestoreObservation `json:"etcdSnapshotRestore,omitempty" tf:"etcd_snapshot_restore,omitempty"`

	// Local auth endpoint configures the Authorized Cluster Endpoint (ACE) which can be used to directly access the Kubernetes API server, without requiring communication through Rancher. For more information, please refer to Rancher Documentation.
	// Cluster V2 local auth endpoint
	LocalAuthEndpoint []RkeConfigLocalAuthEndpointObservation `json:"localAuthEndpoint,omitempty" tf:"local_auth_endpoint,omitempty"`

	// Machine global config specifies the distribution-specified server configuration applied to all nodes. For the full list of server configurations, please refer to RKE2 server configuration or K3s server configuration.
	// Cluster V2 machine global config
	MachineGlobalConfig *string `json:"machineGlobalConfig,omitempty" tf:"machine_global_config,omitempty"`

	// Default values for machine pool configurations if unset
	MachinePoolDefaults []MachinePoolDefaultsObservation `json:"machinePoolDefaults,omitempty" tf:"machine_pool_defaults,omitempty"`

	// Cluster V2 machine pools.
	// Cluster V2 machine pools
	MachinePools []MachinePoolsObservation `json:"machinePools,omitempty" tf:"machine_pools,omitempty"`

	// Machine selector config is the same as machine_global_config except that a label selector can be specified with the configuration. The configuration will only be applied to nodes that match the provided label selector. The configuration from machine_selector_config takes precedence over the one from machine_global_config. This argument is available in Rancher v2.7.2 and later.
	// Cluster V2 machine selector config
	MachineSelectorConfig []MachineSelectorConfigObservation `json:"machineSelectorConfig,omitempty" tf:"machine_selector_config,omitempty"`

	// Machine selector files provide a means to deliver files to nodes so that the files can be in place before initiating RKE2/K3s server or agent processes. Please refer to Rancher documentation for RKE2 Cluster Configuration Reference and K3s Cluster Configuration Reference. This argument is available in Rancher v2.7.2 and later.
	// Cluster V2 machine selector files
	MachineSelectorFiles []MachineSelectorFilesObservation `json:"machineSelectorFiles,omitempty" tf:"machine_selector_files,omitempty"`

	// The networking stack used by the cluster.
	// Cluster V2 networking
	Networking []NetworkingObservation `json:"networking,omitempty" tf:"networking,omitempty"`

	// Docker registries from which the cluster pulls images.
	// Cluster V2 registries
	Registries []RegistriesObservation `json:"registries,omitempty" tf:"registries,omitempty"`

	// Cluster V2 certificate rotation.
	// Cluster V2 certificate rotation
	RotateCertificates []RotateCertificatesObservation `json:"rotateCertificates,omitempty" tf:"rotate_certificates,omitempty"`

	// Cluster upgrade strategy.
	// Cluster V2 upgrade strategy
	UpgradeStrategy []ClusterV2RkeConfigUpgradeStrategyObservation `json:"upgradeStrategy,omitempty" tf:"upgrade_strategy,omitempty"`
}

type ClusterV2RkeConfigParameters struct {

	// The value of the additional manifest is delivered to the path /var/lib/rancher/rke2/server/manifests/rancher/addons.yaml or /var/lib/rancher/k3s/server/manifests/rancher/addons.yaml on the control plane nodes.
	// Cluster V2 additional manifest
	// +kubebuilder:validation:Optional
	AdditionalManifest *string `json:"additionalManifest,omitempty" tf:"additional_manifest,omitempty"`

	// The value for the system charts installed by the distribution. For more information about how RKE2 or K3s manage packaged components, please refer to RKE2 documentation or K3s documentation.
	// Cluster V2 chart values. It should be in YAML format
	// +kubebuilder:validation:Optional
	ChartValues *string `json:"chartValues,omitempty" tf:"chart_values,omitempty"`

	// Data directory configuration for the kubernetes distro, system-agent, and provisioning resources.
	// Cluster V2 data directories
	// +kubebuilder:validation:Optional
	DataDirectories []DataDirectoriesParameters `json:"dataDirectories,omitempty" tf:"data_directories,omitempty"`

	// Etcd configures the behavior of the automatic etcd snapshot feature.
	// Cluster V2 etcd
	// +kubebuilder:validation:Optional
	Etcd []RkeConfigEtcdParameters `json:"etcd,omitempty" tf:"etcd,omitempty"`

	// Cluster V2 etcd snapshot create.
	// Cluster V2 etcd snapshot create
	// +kubebuilder:validation:Optional
	EtcdSnapshotCreate []EtcdSnapshotCreateParameters `json:"etcdSnapshotCreate,omitempty" tf:"etcd_snapshot_create,omitempty"`

	// Cluster V2 etcd snapshot restore.
	// Cluster V2 etcd snapshot restore
	// +kubebuilder:validation:Optional
	EtcdSnapshotRestore []EtcdSnapshotRestoreParameters `json:"etcdSnapshotRestore,omitempty" tf:"etcd_snapshot_restore,omitempty"`

	// Local auth endpoint configures the Authorized Cluster Endpoint (ACE) which can be used to directly access the Kubernetes API server, without requiring communication through Rancher. For more information, please refer to Rancher Documentation.
	// Cluster V2 local auth endpoint
	// +kubebuilder:validation:Optional
	LocalAuthEndpoint []RkeConfigLocalAuthEndpointParameters `json:"localAuthEndpoint,omitempty" tf:"local_auth_endpoint,omitempty"`

	// Machine global config specifies the distribution-specified server configuration applied to all nodes. For the full list of server configurations, please refer to RKE2 server configuration or K3s server configuration.
	// Cluster V2 machine global config
	// +kubebuilder:validation:Optional
	MachineGlobalConfig *string `json:"machineGlobalConfig,omitempty" tf:"machine_global_config,omitempty"`

	// Default values for machine pool configurations if unset
	// +kubebuilder:validation:Optional
	MachinePoolDefaults []MachinePoolDefaultsParameters `json:"machinePoolDefaults,omitempty" tf:"machine_pool_defaults,omitempty"`

	// Cluster V2 machine pools.
	// Cluster V2 machine pools
	// +kubebuilder:validation:Optional
	MachinePools []MachinePoolsParameters `json:"machinePools,omitempty" tf:"machine_pools,omitempty"`

	// Machine selector config is the same as machine_global_config except that a label selector can be specified with the configuration. The configuration will only be applied to nodes that match the provided label selector. The configuration from machine_selector_config takes precedence over the one from machine_global_config. This argument is available in Rancher v2.7.2 and later.
	// Cluster V2 machine selector config
	// +kubebuilder:validation:Optional
	MachineSelectorConfig []MachineSelectorConfigParameters `json:"machineSelectorConfig,omitempty" tf:"machine_selector_config,omitempty"`

	// Machine selector files provide a means to deliver files to nodes so that the files can be in place before initiating RKE2/K3s server or agent processes. Please refer to Rancher documentation for RKE2 Cluster Configuration Reference and K3s Cluster Configuration Reference. This argument is available in Rancher v2.7.2 and later.
	// Cluster V2 machine selector files
	// +kubebuilder:validation:Optional
	MachineSelectorFiles []MachineSelectorFilesParameters `json:"machineSelectorFiles,omitempty" tf:"machine_selector_files,omitempty"`

	// The networking stack used by the cluster.
	// Cluster V2 networking
	// +kubebuilder:validation:Optional
	Networking []NetworkingParameters `json:"networking,omitempty" tf:"networking,omitempty"`

	// Docker registries from which the cluster pulls images.
	// Cluster V2 registries
	// +kubebuilder:validation:Optional
	Registries []RegistriesParameters `json:"registries,omitempty" tf:"registries,omitempty"`

	// Cluster V2 certificate rotation.
	// Cluster V2 certificate rotation
	// +kubebuilder:validation:Optional
	RotateCertificates []RotateCertificatesParameters `json:"rotateCertificates,omitempty" tf:"rotate_certificates,omitempty"`

	// Cluster upgrade strategy.
	// Cluster V2 upgrade strategy
	// +kubebuilder:validation:Optional
	UpgradeStrategy []ClusterV2RkeConfigUpgradeStrategyParameters `json:"upgradeStrategy,omitempty" tf:"upgrade_strategy,omitempty"`
}

type ClusterV2RkeConfigUpgradeStrategyInitParameters struct {

	// How many control plane nodes should be upgraded at a time, 0 is infinite. Percentages are also accepted.
	// How many controlplane nodes should be upgrade at time, 0 is infinite. Percentages are also accepted
	ControlPlaneConcurrency *string `json:"controlPlaneConcurrency,omitempty" tf:"control_plane_concurrency,omitempty"`

	// Controlplane nodes drain options.
	// Controlplane nodes drain options
	ControlPlaneDrainOptions []ControlPlaneDrainOptionsInitParameters `json:"controlPlaneDrainOptions,omitempty" tf:"control_plane_drain_options,omitempty"`

	// How many worker nodes should be upgraded at a time. Percentages are also accepted.
	// How many worker nodes should be upgrade at time
	WorkerConcurrency *string `json:"workerConcurrency,omitempty" tf:"worker_concurrency,omitempty"`

	// Worker nodes drain options.
	// Worker nodes drain options
	WorkerDrainOptions []WorkerDrainOptionsInitParameters `json:"workerDrainOptions,omitempty" tf:"worker_drain_options,omitempty"`
}

type ClusterV2RkeConfigUpgradeStrategyObservation struct {

	// How many control plane nodes should be upgraded at a time, 0 is infinite. Percentages are also accepted.
	// How many controlplane nodes should be upgrade at time, 0 is infinite. Percentages are also accepted
	ControlPlaneConcurrency *string `json:"controlPlaneConcurrency,omitempty" tf:"control_plane_concurrency,omitempty"`

	// Controlplane nodes drain options.
	// Controlplane nodes drain options
	ControlPlaneDrainOptions []ControlPlaneDrainOptionsObservation `json:"controlPlaneDrainOptions,omitempty" tf:"control_plane_drain_options,omitempty"`

	// How many worker nodes should be upgraded at a time. Percentages are also accepted.
	// How many worker nodes should be upgrade at time
	WorkerConcurrency *string `json:"workerConcurrency,omitempty" tf:"worker_concurrency,omitempty"`

	// Worker nodes drain options.
	// Worker nodes drain options
	WorkerDrainOptions []WorkerDrainOptionsObservation `json:"workerDrainOptions,omitempty" tf:"worker_drain_options,omitempty"`
}

type ClusterV2RkeConfigUpgradeStrategyParameters struct {

	// How many control plane nodes should be upgraded at a time, 0 is infinite. Percentages are also accepted.
	// How many controlplane nodes should be upgrade at time, 0 is infinite. Percentages are also accepted
	// +kubebuilder:validation:Optional
	ControlPlaneConcurrency *string `json:"controlPlaneConcurrency,omitempty" tf:"control_plane_concurrency,omitempty"`

	// Controlplane nodes drain options.
	// Controlplane nodes drain options
	// +kubebuilder:validation:Optional
	ControlPlaneDrainOptions []ControlPlaneDrainOptionsParameters `json:"controlPlaneDrainOptions,omitempty" tf:"control_plane_drain_options,omitempty"`

	// How many worker nodes should be upgraded at a time. Percentages are also accepted.
	// How many worker nodes should be upgrade at time
	// +kubebuilder:validation:Optional
	WorkerConcurrency *string `json:"workerConcurrency,omitempty" tf:"worker_concurrency,omitempty"`

	// Worker nodes drain options.
	// Worker nodes drain options
	// +kubebuilder:validation:Optional
	WorkerDrainOptions []WorkerDrainOptionsParameters `json:"workerDrainOptions,omitempty" tf:"worker_drain_options,omitempty"`
}

type ConfigmapInitParameters struct {

	// The numeric representation of the default file permissions for all files defined under the items.
	// The default permissions to be applied when they are not set at the item level
	DefaultPermissions *string `json:"defaultPermissions,omitempty" tf:"default_permissions,omitempty"`

	// Items is a list of configurations for files, such as where to retrieve the content from the source, where to put the file on nodes, and etc.
	// Items(files) to retrieve from the K8s object
	Items []ItemsInitParameters `json:"items,omitempty" tf:"items,omitempty"`

	// The name of the cluster.
	// The name of the K8s object
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type ConfigmapObservation struct {

	// The numeric representation of the default file permissions for all files defined under the items.
	// The default permissions to be applied when they are not set at the item level
	DefaultPermissions *string `json:"defaultPermissions,omitempty" tf:"default_permissions,omitempty"`

	// Items is a list of configurations for files, such as where to retrieve the content from the source, where to put the file on nodes, and etc.
	// Items(files) to retrieve from the K8s object
	Items []ItemsObservation `json:"items,omitempty" tf:"items,omitempty"`

	// The name of the cluster.
	// The name of the K8s object
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type ConfigmapParameters struct {

	// The numeric representation of the default file permissions for all files defined under the items.
	// The default permissions to be applied when they are not set at the item level
	// +kubebuilder:validation:Optional
	DefaultPermissions *string `json:"defaultPermissions,omitempty" tf:"default_permissions,omitempty"`

	// Items is a list of configurations for files, such as where to retrieve the content from the source, where to put the file on nodes, and etc.
	// Items(files) to retrieve from the K8s object
	// +kubebuilder:validation:Optional
	Items []ItemsParameters `json:"items,omitempty" tf:"items,omitempty"`

	// The name of the cluster.
	// The name of the K8s object
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`
}

type ConfigsInitParameters struct {

	// Name of the secret that contains two keys with base64 encoded values: the username and password for the specified custom registry. No secret is required if the system-default-registry is not authenticated.
	// Registry auth config secret name
	AuthConfigSecretName *string `json:"authConfigSecretName,omitempty" tf:"auth_config_secret_name,omitempty"`

	// Registry CA bundle.
	// Registry CA bundle
	CABundle *string `json:"caBundle,omitempty" tf:"ca_bundle,omitempty"`

	// Registry hostname.
	// Registry hostname
	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	// Registry insecure connectivity.
	// Registry insecure connectivity
	Insecure *bool `json:"insecure,omitempty" tf:"insecure,omitempty"`

	// Registry TLS secret name. TLS is a pair of Cert/Key.
	// Registry TLS secret name. TLS is a pair of Cert/Key
	TLSSecretName *string `json:"tlsSecretName,omitempty" tf:"tls_secret_name,omitempty"`
}

type ConfigsObservation struct {

	// Name of the secret that contains two keys with base64 encoded values: the username and password for the specified custom registry. No secret is required if the system-default-registry is not authenticated.
	// Registry auth config secret name
	AuthConfigSecretName *string `json:"authConfigSecretName,omitempty" tf:"auth_config_secret_name,omitempty"`

	// Registry CA bundle.
	// Registry CA bundle
	CABundle *string `json:"caBundle,omitempty" tf:"ca_bundle,omitempty"`

	// Registry hostname.
	// Registry hostname
	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	// Registry insecure connectivity.
	// Registry insecure connectivity
	Insecure *bool `json:"insecure,omitempty" tf:"insecure,omitempty"`

	// Registry TLS secret name. TLS is a pair of Cert/Key.
	// Registry TLS secret name. TLS is a pair of Cert/Key
	TLSSecretName *string `json:"tlsSecretName,omitempty" tf:"tls_secret_name,omitempty"`
}

type ConfigsParameters struct {

	// Name of the secret that contains two keys with base64 encoded values: the username and password for the specified custom registry. No secret is required if the system-default-registry is not authenticated.
	// Registry auth config secret name
	// +kubebuilder:validation:Optional
	AuthConfigSecretName *string `json:"authConfigSecretName,omitempty" tf:"auth_config_secret_name,omitempty"`

	// Registry CA bundle.
	// Registry CA bundle
	// +kubebuilder:validation:Optional
	CABundle *string `json:"caBundle,omitempty" tf:"ca_bundle,omitempty"`

	// Registry hostname.
	// Registry hostname
	// +kubebuilder:validation:Optional
	Hostname *string `json:"hostname" tf:"hostname,omitempty"`

	// Registry insecure connectivity.
	// Registry insecure connectivity
	// +kubebuilder:validation:Optional
	Insecure *bool `json:"insecure,omitempty" tf:"insecure,omitempty"`

	// Registry TLS secret name. TLS is a pair of Cert/Key.
	// Registry TLS secret name. TLS is a pair of Cert/Key
	// +kubebuilder:validation:Optional
	TLSSecretName *string `json:"tlsSecretName,omitempty" tf:"tls_secret_name,omitempty"`
}

type ControlPlaneDrainOptionsInitParameters struct {

	// if delete_empty_dir_data is set to true, continue draining even if there are pods using emptyDir (local storage).
	// Drain options delete empty dir data
	DeleteEmptyDirData *bool `json:"deleteEmptyDirData,omitempty" tf:"delete_empty_dir_data,omitempty"`

	// If disable_eviction is set to true, force drain to use delete rather than evict.
	// Drain options disable eviction
	DisableEviction *bool `json:"disableEviction,omitempty" tf:"disable_eviction,omitempty"`

	// Enable the authorized cluster endpoint.
	// Drain options enabled?
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// If force is set to true, drain nodes even if there are standalone pods that are not managed by a ReplicationController, Job, or DaemonSet. Drain will not proceed without force set to true if there are such pods.
	// Drain options force
	Force *bool `json:"force,omitempty" tf:"force,omitempty"`

	// Time in seconds given to each pod to terminate gracefully. If negative, the default value specified in the pod will be used.
	// Drain options grace period
	GracePeriod *float64 `json:"gracePeriod,omitempty" tf:"grace_period,omitempty"`

	// If ignore_daemon_sets is set to false, drain will not proceed if there are DaemonSet-managed pods.
	// Drain options ignore daemon sets
	IgnoreDaemonSets *bool `json:"ignoreDaemonSets,omitempty" tf:"ignore_daemon_sets,omitempty"`

	// If ignore_errors is set to true,  errors that occurred between drain nodes in group are ignored.
	// Drain options ignore errors
	IgnoreErrors *bool `json:"ignoreErrors,omitempty" tf:"ignore_errors,omitempty"`

	// Skip waiting for the pods that have a DeletionTimeStamp > N seconds to be deleted. Seconds must be greater than 0 to skip. Such pods will be force deleted.
	// Drain options skip wait for delete timeout seconds
	SkipWaitForDeleteTimeoutSeconds *float64 `json:"skipWaitForDeleteTimeoutSeconds,omitempty" tf:"skip_wait_for_delete_timeout_seconds,omitempty"`

	// Time to wait (in seconds) before giving up for one try.
	// Drain options timeout
	Timeout *float64 `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

type ControlPlaneDrainOptionsObservation struct {

	// if delete_empty_dir_data is set to true, continue draining even if there are pods using emptyDir (local storage).
	// Drain options delete empty dir data
	DeleteEmptyDirData *bool `json:"deleteEmptyDirData,omitempty" tf:"delete_empty_dir_data,omitempty"`

	// If disable_eviction is set to true, force drain to use delete rather than evict.
	// Drain options disable eviction
	DisableEviction *bool `json:"disableEviction,omitempty" tf:"disable_eviction,omitempty"`

	// Enable the authorized cluster endpoint.
	// Drain options enabled?
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// If force is set to true, drain nodes even if there are standalone pods that are not managed by a ReplicationController, Job, or DaemonSet. Drain will not proceed without force set to true if there are such pods.
	// Drain options force
	Force *bool `json:"force,omitempty" tf:"force,omitempty"`

	// Time in seconds given to each pod to terminate gracefully. If negative, the default value specified in the pod will be used.
	// Drain options grace period
	GracePeriod *float64 `json:"gracePeriod,omitempty" tf:"grace_period,omitempty"`

	// If ignore_daemon_sets is set to false, drain will not proceed if there are DaemonSet-managed pods.
	// Drain options ignore daemon sets
	IgnoreDaemonSets *bool `json:"ignoreDaemonSets,omitempty" tf:"ignore_daemon_sets,omitempty"`

	// If ignore_errors is set to true,  errors that occurred between drain nodes in group are ignored.
	// Drain options ignore errors
	IgnoreErrors *bool `json:"ignoreErrors,omitempty" tf:"ignore_errors,omitempty"`

	// Skip waiting for the pods that have a DeletionTimeStamp > N seconds to be deleted. Seconds must be greater than 0 to skip. Such pods will be force deleted.
	// Drain options skip wait for delete timeout seconds
	SkipWaitForDeleteTimeoutSeconds *float64 `json:"skipWaitForDeleteTimeoutSeconds,omitempty" tf:"skip_wait_for_delete_timeout_seconds,omitempty"`

	// Time to wait (in seconds) before giving up for one try.
	// Drain options timeout
	Timeout *float64 `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

type ControlPlaneDrainOptionsParameters struct {

	// if delete_empty_dir_data is set to true, continue draining even if there are pods using emptyDir (local storage).
	// Drain options delete empty dir data
	// +kubebuilder:validation:Optional
	DeleteEmptyDirData *bool `json:"deleteEmptyDirData,omitempty" tf:"delete_empty_dir_data,omitempty"`

	// If disable_eviction is set to true, force drain to use delete rather than evict.
	// Drain options disable eviction
	// +kubebuilder:validation:Optional
	DisableEviction *bool `json:"disableEviction,omitempty" tf:"disable_eviction,omitempty"`

	// Enable the authorized cluster endpoint.
	// Drain options enabled?
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// If force is set to true, drain nodes even if there are standalone pods that are not managed by a ReplicationController, Job, or DaemonSet. Drain will not proceed without force set to true if there are such pods.
	// Drain options force
	// +kubebuilder:validation:Optional
	Force *bool `json:"force,omitempty" tf:"force,omitempty"`

	// Time in seconds given to each pod to terminate gracefully. If negative, the default value specified in the pod will be used.
	// Drain options grace period
	// +kubebuilder:validation:Optional
	GracePeriod *float64 `json:"gracePeriod,omitempty" tf:"grace_period,omitempty"`

	// If ignore_daemon_sets is set to false, drain will not proceed if there are DaemonSet-managed pods.
	// Drain options ignore daemon sets
	// +kubebuilder:validation:Optional
	IgnoreDaemonSets *bool `json:"ignoreDaemonSets,omitempty" tf:"ignore_daemon_sets,omitempty"`

	// If ignore_errors is set to true,  errors that occurred between drain nodes in group are ignored.
	// Drain options ignore errors
	// +kubebuilder:validation:Optional
	IgnoreErrors *bool `json:"ignoreErrors,omitempty" tf:"ignore_errors,omitempty"`

	// Skip waiting for the pods that have a DeletionTimeStamp > N seconds to be deleted. Seconds must be greater than 0 to skip. Such pods will be force deleted.
	// Drain options skip wait for delete timeout seconds
	// +kubebuilder:validation:Optional
	SkipWaitForDeleteTimeoutSeconds *float64 `json:"skipWaitForDeleteTimeoutSeconds,omitempty" tf:"skip_wait_for_delete_timeout_seconds,omitempty"`

	// Time to wait (in seconds) before giving up for one try.
	// Drain options timeout
	// +kubebuilder:validation:Optional
	Timeout *float64 `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

type DataDirectoriesInitParameters struct {

	// Kubernetes distro data directory path, rendered as the data-dir argument for provisioning v2 RKE2/K3s clusters. If unspecified, the distro will use the default: /var/lib/rancher/rke2 for RKE2, and /var/lib/rancher/k3s for K3s.
	// Desired k8s distro data directory.
	K8SDistro *string `json:"k8sDistro,omitempty" tf:"k8s_distro,omitempty"`

	// Provisioning data directory path, used for all provisioning data on provisioning v2 downstream cluster nodes. If unspecified, Rancher will use the default: /var/lib/rancher/provisioning.
	// Desired provisioning data directory.
	Provisioning *string `json:"provisioning,omitempty" tf:"provisioning,omitempty"`

	// System agent data directory path, used for all system agent data on provisioning v2 downstream  cluster nodes. If unspecified, the rancher-system-agent will use the default: /var/lib/rancher/agent.
	// Desired System Agent data directory.
	SystemAgent *string `json:"systemAgent,omitempty" tf:"system_agent,omitempty"`
}

type DataDirectoriesObservation struct {

	// Kubernetes distro data directory path, rendered as the data-dir argument for provisioning v2 RKE2/K3s clusters. If unspecified, the distro will use the default: /var/lib/rancher/rke2 for RKE2, and /var/lib/rancher/k3s for K3s.
	// Desired k8s distro data directory.
	K8SDistro *string `json:"k8sDistro,omitempty" tf:"k8s_distro,omitempty"`

	// Provisioning data directory path, used for all provisioning data on provisioning v2 downstream cluster nodes. If unspecified, Rancher will use the default: /var/lib/rancher/provisioning.
	// Desired provisioning data directory.
	Provisioning *string `json:"provisioning,omitempty" tf:"provisioning,omitempty"`

	// System agent data directory path, used for all system agent data on provisioning v2 downstream  cluster nodes. If unspecified, the rancher-system-agent will use the default: /var/lib/rancher/agent.
	// Desired System Agent data directory.
	SystemAgent *string `json:"systemAgent,omitempty" tf:"system_agent,omitempty"`
}

type DataDirectoriesParameters struct {

	// Kubernetes distro data directory path, rendered as the data-dir argument for provisioning v2 RKE2/K3s clusters. If unspecified, the distro will use the default: /var/lib/rancher/rke2 for RKE2, and /var/lib/rancher/k3s for K3s.
	// Desired k8s distro data directory.
	// +kubebuilder:validation:Optional
	K8SDistro *string `json:"k8sDistro,omitempty" tf:"k8s_distro,omitempty"`

	// Provisioning data directory path, used for all provisioning data on provisioning v2 downstream cluster nodes. If unspecified, Rancher will use the default: /var/lib/rancher/provisioning.
	// Desired provisioning data directory.
	// +kubebuilder:validation:Optional
	Provisioning *string `json:"provisioning,omitempty" tf:"provisioning,omitempty"`

	// System agent data directory path, used for all system agent data on provisioning v2 downstream  cluster nodes. If unspecified, the rancher-system-agent will use the default: /var/lib/rancher/agent.
	// Desired System Agent data directory.
	// +kubebuilder:validation:Optional
	SystemAgent *string `json:"systemAgent,omitempty" tf:"system_agent,omitempty"`
}

type EtcdSnapshotCreateInitParameters struct {

	// Desired certificate rotation generation.
	// ETCD generation to initiate a snapshot
	Generation *float64 `json:"generation,omitempty" tf:"generation,omitempty"`
}

type EtcdSnapshotCreateObservation struct {

	// Desired certificate rotation generation.
	// ETCD generation to initiate a snapshot
	Generation *float64 `json:"generation,omitempty" tf:"generation,omitempty"`
}

type EtcdSnapshotCreateParameters struct {

	// Desired certificate rotation generation.
	// ETCD generation to initiate a snapshot
	// +kubebuilder:validation:Optional
	Generation *float64 `json:"generation" tf:"generation,omitempty"`
}

type EtcdSnapshotRestoreInitParameters struct {

	// Desired certificate rotation generation.
	// ETCD snapshot desired generation
	Generation *float64 `json:"generation,omitempty" tf:"generation,omitempty"`

	// The name of the cluster.
	// ETCD snapshot name to restore
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// ETCD restore RKE config (set to none, all, or kubernetesVersion).
	// ETCD restore RKE config (set to none, all, or kubernetesVersion)
	RestoreRkeConfig *string `json:"restoreRkeConfig,omitempty" tf:"restore_rke_config,omitempty"`
}

type EtcdSnapshotRestoreObservation struct {

	// Desired certificate rotation generation.
	// ETCD snapshot desired generation
	Generation *float64 `json:"generation,omitempty" tf:"generation,omitempty"`

	// The name of the cluster.
	// ETCD snapshot name to restore
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// ETCD restore RKE config (set to none, all, or kubernetesVersion).
	// ETCD restore RKE config (set to none, all, or kubernetesVersion)
	RestoreRkeConfig *string `json:"restoreRkeConfig,omitempty" tf:"restore_rke_config,omitempty"`
}

type EtcdSnapshotRestoreParameters struct {

	// Desired certificate rotation generation.
	// ETCD snapshot desired generation
	// +kubebuilder:validation:Optional
	Generation *float64 `json:"generation" tf:"generation,omitempty"`

	// The name of the cluster.
	// ETCD snapshot name to restore
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`

	// ETCD restore RKE config (set to none, all, or kubernetesVersion).
	// ETCD restore RKE config (set to none, all, or kubernetesVersion)
	// +kubebuilder:validation:Optional
	RestoreRkeConfig *string `json:"restoreRkeConfig,omitempty" tf:"restore_rke_config,omitempty"`
}

type FileSourcesInitParameters struct {

	// Configmap represents a K8s configmap which is the source of files. It is mutually exclusive with secret.
	// The configmap which is the source of files
	Configmap []ConfigmapInitParameters `json:"configmap,omitempty" tf:"configmap,omitempty"`

	// Secret represents a K8s secret which is the source of files. It is mutually exclusive with configmap.
	// The secret which is the source of files
	Secret []SecretInitParameters `json:"secret,omitempty" tf:"secret,omitempty"`
}

type FileSourcesObservation struct {

	// Configmap represents a K8s configmap which is the source of files. It is mutually exclusive with secret.
	// The configmap which is the source of files
	Configmap []ConfigmapObservation `json:"configmap,omitempty" tf:"configmap,omitempty"`

	// Secret represents a K8s secret which is the source of files. It is mutually exclusive with configmap.
	// The secret which is the source of files
	Secret []SecretObservation `json:"secret,omitempty" tf:"secret,omitempty"`
}

type FileSourcesParameters struct {

	// Configmap represents a K8s configmap which is the source of files. It is mutually exclusive with secret.
	// The configmap which is the source of files
	// +kubebuilder:validation:Optional
	Configmap []ConfigmapParameters `json:"configmap,omitempty" tf:"configmap,omitempty"`

	// Secret represents a K8s secret which is the source of files. It is mutually exclusive with configmap.
	// The secret which is the source of files
	// +kubebuilder:validation:Optional
	Secret []SecretParameters `json:"secret,omitempty" tf:"secret,omitempty"`
}

type ItemsInitParameters struct {

	// If true, the file is ignored when determining whether the node should be drained before updating the node plan.
	// If ture, the file is ignored when determining whether the node should be drained before updating the node plan (default: true).
	Dynamic *bool `json:"dynamic,omitempty" tf:"dynamic,omitempty"`

	// Hash is the base64 encoded value of the SHA256 checksum of the file's content. If specified, it is used to validate the integrity of the file content.
	// The base64 encoded value of the SHA256 checksum of the file's content
	Hash *string `json:"hash,omitempty" tf:"hash,omitempty"`

	// The toleration key.
	// The key of the item(file) to retrieve
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// Path is the absolute path to put the file in the target node.
	// The path to put the file in the target node
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// Permissions is the numeric representation of the file permission. It takes precedence over the default permissions at the outer level.
	// The numeric representation of the file permissions
	Permissions *string `json:"permissions,omitempty" tf:"permissions,omitempty"`
}

type ItemsObservation struct {

	// If true, the file is ignored when determining whether the node should be drained before updating the node plan.
	// If ture, the file is ignored when determining whether the node should be drained before updating the node plan (default: true).
	Dynamic *bool `json:"dynamic,omitempty" tf:"dynamic,omitempty"`

	// Hash is the base64 encoded value of the SHA256 checksum of the file's content. If specified, it is used to validate the integrity of the file content.
	// The base64 encoded value of the SHA256 checksum of the file's content
	Hash *string `json:"hash,omitempty" tf:"hash,omitempty"`

	// The toleration key.
	// The key of the item(file) to retrieve
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// Path is the absolute path to put the file in the target node.
	// The path to put the file in the target node
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// Permissions is the numeric representation of the file permission. It takes precedence over the default permissions at the outer level.
	// The numeric representation of the file permissions
	Permissions *string `json:"permissions,omitempty" tf:"permissions,omitempty"`
}

type ItemsParameters struct {

	// If true, the file is ignored when determining whether the node should be drained before updating the node plan.
	// If ture, the file is ignored when determining whether the node should be drained before updating the node plan (default: true).
	// +kubebuilder:validation:Optional
	Dynamic *bool `json:"dynamic,omitempty" tf:"dynamic,omitempty"`

	// Hash is the base64 encoded value of the SHA256 checksum of the file's content. If specified, it is used to validate the integrity of the file content.
	// The base64 encoded value of the SHA256 checksum of the file's content
	// +kubebuilder:validation:Optional
	Hash *string `json:"hash,omitempty" tf:"hash,omitempty"`

	// The toleration key.
	// The key of the item(file) to retrieve
	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`

	// Path is the absolute path to put the file in the target node.
	// The path to put the file in the target node
	// +kubebuilder:validation:Optional
	Path *string `json:"path" tf:"path,omitempty"`

	// Permissions is the numeric representation of the file permission. It takes precedence over the default permissions at the outer level.
	// The numeric representation of the file permissions
	// +kubebuilder:validation:Optional
	Permissions *string `json:"permissions,omitempty" tf:"permissions,omitempty"`
}

type LocalAuthEndpointInitParameters struct {

	// CA certs for the authorized cluster endpoint. It is only needed if there is a load balancer in front of the downstream cluster that is using an untrusted certificate. If you have a valid certificate, then nothing needs to be added to the CA Certificates field.
	CACerts *string `json:"caCerts,omitempty" tf:"ca_certs,omitempty"`

	// Enable the authorized cluster endpoint.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// FQDN for the authorized cluster endpoint. If one is entered, it should point to the downstream cluster.
	Fqdn *string `json:"fqdn,omitempty" tf:"fqdn,omitempty"`
}

type LocalAuthEndpointObservation struct {

	// CA certs for the authorized cluster endpoint. It is only needed if there is a load balancer in front of the downstream cluster that is using an untrusted certificate. If you have a valid certificate, then nothing needs to be added to the CA Certificates field.
	CACerts *string `json:"caCerts,omitempty" tf:"ca_certs,omitempty"`

	// Enable the authorized cluster endpoint.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// FQDN for the authorized cluster endpoint. If one is entered, it should point to the downstream cluster.
	Fqdn *string `json:"fqdn,omitempty" tf:"fqdn,omitempty"`
}

type LocalAuthEndpointParameters struct {

	// CA certs for the authorized cluster endpoint. It is only needed if there is a load balancer in front of the downstream cluster that is using an untrusted certificate. If you have a valid certificate, then nothing needs to be added to the CA Certificates field.
	// +kubebuilder:validation:Optional
	CACerts *string `json:"caCerts,omitempty" tf:"ca_certs,omitempty"`

	// Enable the authorized cluster endpoint.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// FQDN for the authorized cluster endpoint. If one is entered, it should point to the downstream cluster.
	// +kubebuilder:validation:Optional
	Fqdn *string `json:"fqdn,omitempty" tf:"fqdn,omitempty"`
}

type MachineConfigInitParameters struct {

	// Api version of the machine_config.
	// Machine config API version
	APIVersion *string `json:"apiVersion,omitempty" tf:"api_version,omitempty"`

	// Machine config kind.
	// Machine config kind
	Kind *string `json:"kind,omitempty" tf:"kind,omitempty"`

	// The name of the cluster.
	// Machine config name
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type MachineConfigObservation struct {

	// Api version of the machine_config.
	// Machine config API version
	APIVersion *string `json:"apiVersion,omitempty" tf:"api_version,omitempty"`

	// Machine config kind.
	// Machine config kind
	Kind *string `json:"kind,omitempty" tf:"kind,omitempty"`

	// The name of the cluster.
	// Machine config name
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type MachineConfigParameters struct {

	// Api version of the machine_config.
	// Machine config API version
	// +kubebuilder:validation:Optional
	APIVersion *string `json:"apiVersion,omitempty" tf:"api_version,omitempty"`

	// Machine config kind.
	// Machine config kind
	// +kubebuilder:validation:Optional
	Kind *string `json:"kind" tf:"kind,omitempty"`

	// The name of the cluster.
	// Machine config name
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`
}

type MachineLabelSelectorInitParameters struct {

	// Match expressions is a list of label selector requirements. The requirements are ANDed.
	// Label selector match expressions
	MatchExpressions []MatchExpressionsInitParameters `json:"matchExpressions,omitempty" tf:"match_expressions,omitempty"`

	// Machine selector label is a map of {key,value} pairs, the requirements are ANDed.
	// Label selector match labels
	// +mapType=granular
	MatchLabels map[string]*string `json:"matchLabels,omitempty" tf:"match_labels,omitempty"`
}

type MachineLabelSelectorMatchExpressionsInitParameters struct {

	// The toleration key.
	// Label selector requirement key
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The toleration operator.
	// Label selector operator
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// Values is a list of string values.
	// Label selector requirement values
	Values []*string `json:"values,omitempty" tf:"values,omitempty"`
}

type MachineLabelSelectorMatchExpressionsObservation struct {

	// The toleration key.
	// Label selector requirement key
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The toleration operator.
	// Label selector operator
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// Values is a list of string values.
	// Label selector requirement values
	Values []*string `json:"values,omitempty" tf:"values,omitempty"`
}

type MachineLabelSelectorMatchExpressionsParameters struct {

	// The toleration key.
	// Label selector requirement key
	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The toleration operator.
	// Label selector operator
	// +kubebuilder:validation:Optional
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// Values is a list of string values.
	// Label selector requirement values
	// +kubebuilder:validation:Optional
	Values []*string `json:"values,omitempty" tf:"values,omitempty"`
}

type MachineLabelSelectorObservation struct {

	// Match expressions is a list of label selector requirements. The requirements are ANDed.
	// Label selector match expressions
	MatchExpressions []MatchExpressionsObservation `json:"matchExpressions,omitempty" tf:"match_expressions,omitempty"`

	// Machine selector label is a map of {key,value} pairs, the requirements are ANDed.
	// Label selector match labels
	// +mapType=granular
	MatchLabels map[string]*string `json:"matchLabels,omitempty" tf:"match_labels,omitempty"`
}

type MachineLabelSelectorParameters struct {

	// Match expressions is a list of label selector requirements. The requirements are ANDed.
	// Label selector match expressions
	// +kubebuilder:validation:Optional
	MatchExpressions []MatchExpressionsParameters `json:"matchExpressions,omitempty" tf:"match_expressions,omitempty"`

	// Machine selector label is a map of {key,value} pairs, the requirements are ANDed.
	// Label selector match labels
	// +kubebuilder:validation:Optional
	// +mapType=granular
	MatchLabels map[string]*string `json:"matchLabels,omitempty" tf:"match_labels,omitempty"`
}

type MachinePoolDefaultsInitParameters struct {

	// maximum length for autogenerated hostname
	HostnameLengthLimit *float64 `json:"hostnameLengthLimit,omitempty" tf:"hostname_length_limit,omitempty"`
}

type MachinePoolDefaultsObservation struct {

	// maximum length for autogenerated hostname
	HostnameLengthLimit *float64 `json:"hostnameLengthLimit,omitempty" tf:"hostname_length_limit,omitempty"`
}

type MachinePoolDefaultsParameters struct {

	// maximum length for autogenerated hostname
	// +kubebuilder:validation:Optional
	HostnameLengthLimit *float64 `json:"hostnameLengthLimit,omitempty" tf:"hostname_length_limit,omitempty"`
}

type MachinePoolsInitParameters struct {

	// Annotations for the Cluster.
	// Annotations for the MachineDeployment object
	// +mapType=granular
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// Cloud credential secret name is the secret to be used when a cloud credential secret name is not specified at the machine pool level.
	// Machine pool cloud credential secret name
	CloudCredentialSecretName *string `json:"cloudCredentialSecretName,omitempty" tf:"cloud_credential_secret_name,omitempty"`

	// Machine pool control plane role?
	// Machine pool control plane role
	ControlPlaneRole *bool `json:"controlPlaneRole,omitempty" tf:"control_plane_role,omitempty"`

	// Machine Pool Drain Before Delete?
	// Machine pool drain before delete
	DrainBeforeDelete *bool `json:"drainBeforeDelete,omitempty" tf:"drain_before_delete,omitempty"`

	// Machine pool etcd role?
	// Machine pool etcd role
	EtcdRole *bool `json:"etcdRole,omitempty" tf:"etcd_role,omitempty"`

	// maximum length for autogenerated hostname
	HostnameLengthLimit *float64 `json:"hostnameLengthLimit,omitempty" tf:"hostname_length_limit,omitempty"`

	// Labels for the Cluster.
	// Labels for the MachineDeployment object
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// Machine pool node config.
	// Machine config data
	MachineConfig []MachineConfigInitParameters `json:"machineConfig,omitempty" tf:"machine_config,omitempty"`

	// Labels for Machine pool nodes.
	// Labels for the machine pool nodes
	// +mapType=granular
	MachineLabels map[string]*string `json:"machineLabels,omitempty" tf:"machine_labels,omitempty"`

	// OS Type in machine pool. Default linux(string)
	// OS Type in machine pool
	MachineOs *string `json:"machineOs,omitempty" tf:"machine_os,omitempty"`

	// Max unhealthy nodes for automated replacement to be allowed.
	// max unhealthy nodes for automated replacement to be allowed
	MaxUnhealthy *string `json:"maxUnhealthy,omitempty" tf:"max_unhealthy,omitempty"`

	// The name of the cluster.
	// Machine pool name
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Seconds a machine has to drain before deletion.
	// seconds to wait for machine pool drain to complete before machine deletion
	NodeDrainTimeout *float64 `json:"nodeDrainTimeout,omitempty" tf:"node_drain_timeout,omitempty"`

	// Seconds a new node has to become active before it is replaced.
	// seconds a new node has to become active before it is replaced
	NodeStartupTimeoutSeconds *float64 `json:"nodeStartupTimeoutSeconds,omitempty" tf:"node_startup_timeout_seconds,omitempty"`

	// Machine pool paused?
	// Machine pool paused
	Paused *bool `json:"paused,omitempty" tf:"paused,omitempty"`

	// Machine pool quantity.
	// Machine pool quantity
	Quantity *float64 `json:"quantity,omitempty" tf:"quantity,omitempty"`

	// Machine pool rolling update.
	// Machine pool rolling update
	RollingUpdate []MachinePoolsRollingUpdateInitParameters `json:"rollingUpdate,omitempty" tf:"rolling_update,omitempty"`

	// Machine pool taints.
	// Machine pool taints
	Taints []MachinePoolsTaintsInitParameters `json:"taints,omitempty" tf:"taints,omitempty"`

	// Seconds an unhealthy node has to become active before it is replaced.
	// seconds an unhealthy node has to become active before it is replaced
	UnhealthyNodeTimeoutSeconds *float64 `json:"unhealthyNodeTimeoutSeconds,omitempty" tf:"unhealthy_node_timeout_seconds,omitempty"`

	// Range of unhealthy nodes for automated replacement to be allowed.
	// range of unhealthy nodes for automated replacement to be allowed
	UnhealthyRange *string `json:"unhealthyRange,omitempty" tf:"unhealthy_range,omitempty"`

	// Machine pool worker role?
	// Machine pool worker role
	WorkerRole *bool `json:"workerRole,omitempty" tf:"worker_role,omitempty"`
}

type MachinePoolsObservation struct {

	// Annotations for the Cluster.
	// Annotations for the MachineDeployment object
	// +mapType=granular
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// Cloud credential secret name is the secret to be used when a cloud credential secret name is not specified at the machine pool level.
	// Machine pool cloud credential secret name
	CloudCredentialSecretName *string `json:"cloudCredentialSecretName,omitempty" tf:"cloud_credential_secret_name,omitempty"`

	// Machine pool control plane role?
	// Machine pool control plane role
	ControlPlaneRole *bool `json:"controlPlaneRole,omitempty" tf:"control_plane_role,omitempty"`

	// Machine Pool Drain Before Delete?
	// Machine pool drain before delete
	DrainBeforeDelete *bool `json:"drainBeforeDelete,omitempty" tf:"drain_before_delete,omitempty"`

	// Machine pool etcd role?
	// Machine pool etcd role
	EtcdRole *bool `json:"etcdRole,omitempty" tf:"etcd_role,omitempty"`

	// maximum length for autogenerated hostname
	HostnameLengthLimit *float64 `json:"hostnameLengthLimit,omitempty" tf:"hostname_length_limit,omitempty"`

	// Labels for the Cluster.
	// Labels for the MachineDeployment object
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// Machine pool node config.
	// Machine config data
	MachineConfig []MachineConfigObservation `json:"machineConfig,omitempty" tf:"machine_config,omitempty"`

	// Labels for Machine pool nodes.
	// Labels for the machine pool nodes
	// +mapType=granular
	MachineLabels map[string]*string `json:"machineLabels,omitempty" tf:"machine_labels,omitempty"`

	// OS Type in machine pool. Default linux(string)
	// OS Type in machine pool
	MachineOs *string `json:"machineOs,omitempty" tf:"machine_os,omitempty"`

	// Max unhealthy nodes for automated replacement to be allowed.
	// max unhealthy nodes for automated replacement to be allowed
	MaxUnhealthy *string `json:"maxUnhealthy,omitempty" tf:"max_unhealthy,omitempty"`

	// The name of the cluster.
	// Machine pool name
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Seconds a machine has to drain before deletion.
	// seconds to wait for machine pool drain to complete before machine deletion
	NodeDrainTimeout *float64 `json:"nodeDrainTimeout,omitempty" tf:"node_drain_timeout,omitempty"`

	// Seconds a new node has to become active before it is replaced.
	// seconds a new node has to become active before it is replaced
	NodeStartupTimeoutSeconds *float64 `json:"nodeStartupTimeoutSeconds,omitempty" tf:"node_startup_timeout_seconds,omitempty"`

	// Machine pool paused?
	// Machine pool paused
	Paused *bool `json:"paused,omitempty" tf:"paused,omitempty"`

	// Machine pool quantity.
	// Machine pool quantity
	Quantity *float64 `json:"quantity,omitempty" tf:"quantity,omitempty"`

	// Machine pool rolling update.
	// Machine pool rolling update
	RollingUpdate []MachinePoolsRollingUpdateObservation `json:"rollingUpdate,omitempty" tf:"rolling_update,omitempty"`

	// Machine pool taints.
	// Machine pool taints
	Taints []MachinePoolsTaintsObservation `json:"taints,omitempty" tf:"taints,omitempty"`

	// Seconds an unhealthy node has to become active before it is replaced.
	// seconds an unhealthy node has to become active before it is replaced
	UnhealthyNodeTimeoutSeconds *float64 `json:"unhealthyNodeTimeoutSeconds,omitempty" tf:"unhealthy_node_timeout_seconds,omitempty"`

	// Range of unhealthy nodes for automated replacement to be allowed.
	// range of unhealthy nodes for automated replacement to be allowed
	UnhealthyRange *string `json:"unhealthyRange,omitempty" tf:"unhealthy_range,omitempty"`

	// Machine pool worker role?
	// Machine pool worker role
	WorkerRole *bool `json:"workerRole,omitempty" tf:"worker_role,omitempty"`
}

type MachinePoolsParameters struct {

	// Annotations for the Cluster.
	// Annotations for the MachineDeployment object
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Annotations map[string]*string `json:"annotations,omitempty" tf:"annotations,omitempty"`

	// Cloud credential secret name is the secret to be used when a cloud credential secret name is not specified at the machine pool level.
	// Machine pool cloud credential secret name
	// +kubebuilder:validation:Optional
	CloudCredentialSecretName *string `json:"cloudCredentialSecretName,omitempty" tf:"cloud_credential_secret_name,omitempty"`

	// Machine pool control plane role?
	// Machine pool control plane role
	// +kubebuilder:validation:Optional
	ControlPlaneRole *bool `json:"controlPlaneRole,omitempty" tf:"control_plane_role,omitempty"`

	// Machine Pool Drain Before Delete?
	// Machine pool drain before delete
	// +kubebuilder:validation:Optional
	DrainBeforeDelete *bool `json:"drainBeforeDelete,omitempty" tf:"drain_before_delete,omitempty"`

	// Machine pool etcd role?
	// Machine pool etcd role
	// +kubebuilder:validation:Optional
	EtcdRole *bool `json:"etcdRole,omitempty" tf:"etcd_role,omitempty"`

	// maximum length for autogenerated hostname
	// +kubebuilder:validation:Optional
	HostnameLengthLimit *float64 `json:"hostnameLengthLimit,omitempty" tf:"hostname_length_limit,omitempty"`

	// Labels for the Cluster.
	// Labels for the MachineDeployment object
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// Machine pool node config.
	// Machine config data
	// +kubebuilder:validation:Optional
	MachineConfig []MachineConfigParameters `json:"machineConfig" tf:"machine_config,omitempty"`

	// Labels for Machine pool nodes.
	// Labels for the machine pool nodes
	// +kubebuilder:validation:Optional
	// +mapType=granular
	MachineLabels map[string]*string `json:"machineLabels,omitempty" tf:"machine_labels,omitempty"`

	// OS Type in machine pool. Default linux(string)
	// OS Type in machine pool
	// +kubebuilder:validation:Optional
	MachineOs *string `json:"machineOs,omitempty" tf:"machine_os,omitempty"`

	// Max unhealthy nodes for automated replacement to be allowed.
	// max unhealthy nodes for automated replacement to be allowed
	// +kubebuilder:validation:Optional
	MaxUnhealthy *string `json:"maxUnhealthy,omitempty" tf:"max_unhealthy,omitempty"`

	// The name of the cluster.
	// Machine pool name
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`

	// Seconds a machine has to drain before deletion.
	// seconds to wait for machine pool drain to complete before machine deletion
	// +kubebuilder:validation:Optional
	NodeDrainTimeout *float64 `json:"nodeDrainTimeout,omitempty" tf:"node_drain_timeout,omitempty"`

	// Seconds a new node has to become active before it is replaced.
	// seconds a new node has to become active before it is replaced
	// +kubebuilder:validation:Optional
	NodeStartupTimeoutSeconds *float64 `json:"nodeStartupTimeoutSeconds,omitempty" tf:"node_startup_timeout_seconds,omitempty"`

	// Machine pool paused?
	// Machine pool paused
	// +kubebuilder:validation:Optional
	Paused *bool `json:"paused,omitempty" tf:"paused,omitempty"`

	// Machine pool quantity.
	// Machine pool quantity
	// +kubebuilder:validation:Optional
	Quantity *float64 `json:"quantity,omitempty" tf:"quantity,omitempty"`

	// Machine pool rolling update.
	// Machine pool rolling update
	// +kubebuilder:validation:Optional
	RollingUpdate []MachinePoolsRollingUpdateParameters `json:"rollingUpdate,omitempty" tf:"rolling_update,omitempty"`

	// Machine pool taints.
	// Machine pool taints
	// +kubebuilder:validation:Optional
	Taints []MachinePoolsTaintsParameters `json:"taints,omitempty" tf:"taints,omitempty"`

	// Seconds an unhealthy node has to become active before it is replaced.
	// seconds an unhealthy node has to become active before it is replaced
	// +kubebuilder:validation:Optional
	UnhealthyNodeTimeoutSeconds *float64 `json:"unhealthyNodeTimeoutSeconds,omitempty" tf:"unhealthy_node_timeout_seconds,omitempty"`

	// Range of unhealthy nodes for automated replacement to be allowed.
	// range of unhealthy nodes for automated replacement to be allowed
	// +kubebuilder:validation:Optional
	UnhealthyRange *string `json:"unhealthyRange,omitempty" tf:"unhealthy_range,omitempty"`

	// Machine pool worker role?
	// Machine pool worker role
	// +kubebuilder:validation:Optional
	WorkerRole *bool `json:"workerRole,omitempty" tf:"worker_role,omitempty"`
}

type MachinePoolsRollingUpdateInitParameters struct {

	// Rolling update max surge.
	// Rolling update max surge
	MaxSurge *string `json:"maxSurge,omitempty" tf:"max_surge,omitempty"`

	// The maximum number of agent replicas that can be unavailable at a given time. This can be a non-negative whole number or a whole number percentage (e.g. "1", "50%"). This field cannot be used at the same time as min_available.
	// Rolling update max unavailable
	MaxUnavailable *string `json:"maxUnavailable,omitempty" tf:"max_unavailable,omitempty"`
}

type MachinePoolsRollingUpdateObservation struct {

	// Rolling update max surge.
	// Rolling update max surge
	MaxSurge *string `json:"maxSurge,omitempty" tf:"max_surge,omitempty"`

	// The maximum number of agent replicas that can be unavailable at a given time. This can be a non-negative whole number or a whole number percentage (e.g. "1", "50%"). This field cannot be used at the same time as min_available.
	// Rolling update max unavailable
	MaxUnavailable *string `json:"maxUnavailable,omitempty" tf:"max_unavailable,omitempty"`
}

type MachinePoolsRollingUpdateParameters struct {

	// Rolling update max surge.
	// Rolling update max surge
	// +kubebuilder:validation:Optional
	MaxSurge *string `json:"maxSurge,omitempty" tf:"max_surge,omitempty"`

	// The maximum number of agent replicas that can be unavailable at a given time. This can be a non-negative whole number or a whole number percentage (e.g. "1", "50%"). This field cannot be used at the same time as min_available.
	// Rolling update max unavailable
	// +kubebuilder:validation:Optional
	MaxUnavailable *string `json:"maxUnavailable,omitempty" tf:"max_unavailable,omitempty"`
}

type MachinePoolsTaintsInitParameters struct {

	// The toleration effect. Default: \"NoSchedule\".
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// The toleration key.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// Rancher agent env var value.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type MachinePoolsTaintsObservation struct {

	// The toleration effect. Default: \"NoSchedule\".
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// The toleration key.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// Rancher agent env var value.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type MachinePoolsTaintsParameters struct {

	// The toleration effect. Default: \"NoSchedule\".
	// +kubebuilder:validation:Optional
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// The toleration key.
	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`

	// Rancher agent env var value.
	// +kubebuilder:validation:Optional
	Value *string `json:"value" tf:"value,omitempty"`
}

type MachineSelectorConfigInitParameters struct {

	// Config is the distribution-specify configuration to be applied to nodes that match the provided label selector. For more information, please refer to Rancher's documentation for RKE2 Cluster Configuration or K3s Cluster Configuration
	// Machine selector config
	Config *string `json:"config,omitempty" tf:"config,omitempty"`

	// Machine selector label is a label query over a set of resources. The result of match_labels and match_expressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
	// Machine label selector
	MachineLabelSelector []MachineLabelSelectorInitParameters `json:"machineLabelSelector,omitempty" tf:"machine_label_selector,omitempty"`
}

type MachineSelectorConfigObservation struct {

	// Config is the distribution-specify configuration to be applied to nodes that match the provided label selector. For more information, please refer to Rancher's documentation for RKE2 Cluster Configuration or K3s Cluster Configuration
	// Machine selector config
	Config *string `json:"config,omitempty" tf:"config,omitempty"`

	// Machine selector label is a label query over a set of resources. The result of match_labels and match_expressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
	// Machine label selector
	MachineLabelSelector []MachineLabelSelectorObservation `json:"machineLabelSelector,omitempty" tf:"machine_label_selector,omitempty"`
}

type MachineSelectorConfigParameters struct {

	// Config is the distribution-specify configuration to be applied to nodes that match the provided label selector. For more information, please refer to Rancher's documentation for RKE2 Cluster Configuration or K3s Cluster Configuration
	// Machine selector config
	// +kubebuilder:validation:Optional
	Config *string `json:"config,omitempty" tf:"config,omitempty"`

	// Machine selector label is a label query over a set of resources. The result of match_labels and match_expressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
	// Machine label selector
	// +kubebuilder:validation:Optional
	MachineLabelSelector []MachineLabelSelectorParameters `json:"machineLabelSelector,omitempty" tf:"machine_label_selector,omitempty"`
}

type MachineSelectorFilesInitParameters struct {

	// File sources represents the source of the files. Multiple files can be delivered to nodes that match the provided label selector.
	// File sources
	FileSources []FileSourcesInitParameters `json:"fileSources,omitempty" tf:"file_sources,omitempty"`

	// Machine selector label is a label query over a set of resources. The result of match_labels and match_expressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
	// Machine label selector
	MachineLabelSelector []MachineSelectorFilesMachineLabelSelectorInitParameters `json:"machineLabelSelector,omitempty" tf:"machine_label_selector,omitempty"`
}

type MachineSelectorFilesMachineLabelSelectorInitParameters struct {

	// Match expressions is a list of label selector requirements. The requirements are ANDed.
	// Label selector match expressions
	MatchExpressions []MachineLabelSelectorMatchExpressionsInitParameters `json:"matchExpressions,omitempty" tf:"match_expressions,omitempty"`

	// Machine selector label is a map of {key,value} pairs, the requirements are ANDed.
	// Label selector match labels
	// +mapType=granular
	MatchLabels map[string]*string `json:"matchLabels,omitempty" tf:"match_labels,omitempty"`
}

type MachineSelectorFilesMachineLabelSelectorObservation struct {

	// Match expressions is a list of label selector requirements. The requirements are ANDed.
	// Label selector match expressions
	MatchExpressions []MachineLabelSelectorMatchExpressionsObservation `json:"matchExpressions,omitempty" tf:"match_expressions,omitempty"`

	// Machine selector label is a map of {key,value} pairs, the requirements are ANDed.
	// Label selector match labels
	// +mapType=granular
	MatchLabels map[string]*string `json:"matchLabels,omitempty" tf:"match_labels,omitempty"`
}

type MachineSelectorFilesMachineLabelSelectorParameters struct {

	// Match expressions is a list of label selector requirements. The requirements are ANDed.
	// Label selector match expressions
	// +kubebuilder:validation:Optional
	MatchExpressions []MachineLabelSelectorMatchExpressionsParameters `json:"matchExpressions,omitempty" tf:"match_expressions,omitempty"`

	// Machine selector label is a map of {key,value} pairs, the requirements are ANDed.
	// Label selector match labels
	// +kubebuilder:validation:Optional
	// +mapType=granular
	MatchLabels map[string]*string `json:"matchLabels,omitempty" tf:"match_labels,omitempty"`
}

type MachineSelectorFilesObservation struct {

	// File sources represents the source of the files. Multiple files can be delivered to nodes that match the provided label selector.
	// File sources
	FileSources []FileSourcesObservation `json:"fileSources,omitempty" tf:"file_sources,omitempty"`

	// Machine selector label is a label query over a set of resources. The result of match_labels and match_expressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
	// Machine label selector
	MachineLabelSelector []MachineSelectorFilesMachineLabelSelectorObservation `json:"machineLabelSelector,omitempty" tf:"machine_label_selector,omitempty"`
}

type MachineSelectorFilesParameters struct {

	// File sources represents the source of the files. Multiple files can be delivered to nodes that match the provided label selector.
	// File sources
	// +kubebuilder:validation:Optional
	FileSources []FileSourcesParameters `json:"fileSources,omitempty" tf:"file_sources,omitempty"`

	// Machine selector label is a label query over a set of resources. The result of match_labels and match_expressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
	// Machine label selector
	// +kubebuilder:validation:Optional
	MachineLabelSelector []MachineSelectorFilesMachineLabelSelectorParameters `json:"machineLabelSelector,omitempty" tf:"machine_label_selector,omitempty"`
}

type MatchExpressionsInitParameters struct {

	// The toleration key.
	// Label selector requirement key
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The toleration operator.
	// Label selector operator
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// Values is a list of string values.
	// Label selector requirement values
	Values []*string `json:"values,omitempty" tf:"values,omitempty"`
}

type MatchExpressionsObservation struct {

	// The toleration key.
	// Label selector requirement key
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The toleration operator.
	// Label selector operator
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// Values is a list of string values.
	// Label selector requirement values
	Values []*string `json:"values,omitempty" tf:"values,omitempty"`
}

type MatchExpressionsParameters struct {

	// The toleration key.
	// Label selector requirement key
	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The toleration operator.
	// Label selector operator
	// +kubebuilder:validation:Optional
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// Values is a list of string values.
	// Label selector requirement values
	// +kubebuilder:validation:Optional
	Values []*string `json:"values,omitempty" tf:"values,omitempty"`
}

type MirrorsInitParameters struct {

	// Registry mirror endpoints.
	// Registry mirror endpoints
	Endpoints []*string `json:"endpoints,omitempty" tf:"endpoints,omitempty"`

	// Registry hostname.
	// Registry hostname
	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	// Registry mirror rewrites.
	// Registry mirror rewrites
	// +mapType=granular
	Rewrites map[string]*string `json:"rewrites,omitempty" tf:"rewrites,omitempty"`
}

type MirrorsObservation struct {

	// Registry mirror endpoints.
	// Registry mirror endpoints
	Endpoints []*string `json:"endpoints,omitempty" tf:"endpoints,omitempty"`

	// Registry hostname.
	// Registry hostname
	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	// Registry mirror rewrites.
	// Registry mirror rewrites
	// +mapType=granular
	Rewrites map[string]*string `json:"rewrites,omitempty" tf:"rewrites,omitempty"`
}

type MirrorsParameters struct {

	// Registry mirror endpoints.
	// Registry mirror endpoints
	// +kubebuilder:validation:Optional
	Endpoints []*string `json:"endpoints,omitempty" tf:"endpoints,omitempty"`

	// Registry hostname.
	// Registry hostname
	// +kubebuilder:validation:Optional
	Hostname *string `json:"hostname" tf:"hostname,omitempty"`

	// Registry mirror rewrites.
	// Registry mirror rewrites
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Rewrites map[string]*string `json:"rewrites,omitempty" tf:"rewrites,omitempty"`
}

type NetworkingInitParameters struct {

	// The networking stack used by the cluster. The selected value configures the address used for health and readiness probes of calico, etcd, kube-apiserver, kube-scheduler, kube-controller-manager, and kubelet. It also defines the server URL in the authentication-token-webhook-config-file for the Authorized Cluster Endpoint and the advertise-client-urls for etcd during snapshot restore.  When set to dual, the cluster uses localhost; when set to ipv6, it uses [::1]; when set to ipv4, it uses 127.0.0.1.
	// Specify the networking stack used by the cluster. The selected value configures the address used for health and readiness probes of calico, etcd, kube-apiserver, kube-scheduler, kube-controller-manager, and kubelet. It also defines the server URL in the authentication-token-webhook-config-file for the Authorized Cluster Endpoint and the advertise-client-urls for etcd during snapshot restore. When set to dual, the cluster uses localhost; when set to ipv6, it uses [::1]; when set to ipv4, it uses 127.0.0.1
	StackPreference *string `json:"stackPreference,omitempty" tf:"stack_preference,omitempty"`
}

type NetworkingObservation struct {

	// The networking stack used by the cluster. The selected value configures the address used for health and readiness probes of calico, etcd, kube-apiserver, kube-scheduler, kube-controller-manager, and kubelet. It also defines the server URL in the authentication-token-webhook-config-file for the Authorized Cluster Endpoint and the advertise-client-urls for etcd during snapshot restore.  When set to dual, the cluster uses localhost; when set to ipv6, it uses [::1]; when set to ipv4, it uses 127.0.0.1.
	// Specify the networking stack used by the cluster. The selected value configures the address used for health and readiness probes of calico, etcd, kube-apiserver, kube-scheduler, kube-controller-manager, and kubelet. It also defines the server URL in the authentication-token-webhook-config-file for the Authorized Cluster Endpoint and the advertise-client-urls for etcd during snapshot restore. When set to dual, the cluster uses localhost; when set to ipv6, it uses [::1]; when set to ipv4, it uses 127.0.0.1
	StackPreference *string `json:"stackPreference,omitempty" tf:"stack_preference,omitempty"`
}

type NetworkingParameters struct {

	// The networking stack used by the cluster. The selected value configures the address used for health and readiness probes of calico, etcd, kube-apiserver, kube-scheduler, kube-controller-manager, and kubelet. It also defines the server URL in the authentication-token-webhook-config-file for the Authorized Cluster Endpoint and the advertise-client-urls for etcd during snapshot restore.  When set to dual, the cluster uses localhost; when set to ipv6, it uses [::1]; when set to ipv4, it uses 127.0.0.1.
	// Specify the networking stack used by the cluster. The selected value configures the address used for health and readiness probes of calico, etcd, kube-apiserver, kube-scheduler, kube-controller-manager, and kubelet. It also defines the server URL in the authentication-token-webhook-config-file for the Authorized Cluster Endpoint and the advertise-client-urls for etcd during snapshot restore. When set to dual, the cluster uses localhost; when set to ipv6, it uses [::1]; when set to ipv4, it uses 127.0.0.1
	// +kubebuilder:validation:Optional
	StackPreference *string `json:"stackPreference,omitempty" tf:"stack_preference,omitempty"`
}

type RegistriesInitParameters struct {

	// Cluster V2 docker registries config.
	// Registry config
	Configs []ConfigsInitParameters `json:"configs,omitempty" tf:"configs,omitempty"`

	// Cluster V2 docker registries mirror.
	// Registry mirrors
	Mirrors []MirrorsInitParameters `json:"mirrors,omitempty" tf:"mirrors,omitempty"`
}

type RegistriesObservation struct {

	// Cluster V2 docker registries config.
	// Registry config
	Configs []ConfigsObservation `json:"configs,omitempty" tf:"configs,omitempty"`

	// Cluster V2 docker registries mirror.
	// Registry mirrors
	Mirrors []MirrorsObservation `json:"mirrors,omitempty" tf:"mirrors,omitempty"`
}

type RegistriesParameters struct {

	// Cluster V2 docker registries config.
	// Registry config
	// +kubebuilder:validation:Optional
	Configs []ConfigsParameters `json:"configs,omitempty" tf:"configs,omitempty"`

	// Cluster V2 docker registries mirror.
	// Registry mirrors
	// +kubebuilder:validation:Optional
	Mirrors []MirrorsParameters `json:"mirrors,omitempty" tf:"mirrors,omitempty"`
}

type RkeConfigEtcdInitParameters struct {

	// Disable ETCD snapshots.
	// Disable ETCD snapshots
	DisableSnapshots *bool `json:"disableSnapshots,omitempty" tf:"disable_snapshots,omitempty"`

	// Creation option for etcd service.
	// ETCD snapshot S3 config
	S3Config []S3ConfigInitParameters `json:"s3Config,omitempty" tf:"s3_config,omitempty"`

	// ETCD snapshot retention.
	// ETCD snapshot retention
	SnapshotRetention *float64 `json:"snapshotRetention,omitempty" tf:"snapshot_retention,omitempty"`

	// ETCD snapshot schedule cron (e.g \"0 */5 * * *\").
	// ETCD snapshot schedule cron (e.g `"0 */5 * * *"`)
	SnapshotScheduleCron *string `json:"snapshotScheduleCron,omitempty" tf:"snapshot_schedule_cron,omitempty"`
}

type RkeConfigEtcdObservation struct {

	// Disable ETCD snapshots.
	// Disable ETCD snapshots
	DisableSnapshots *bool `json:"disableSnapshots,omitempty" tf:"disable_snapshots,omitempty"`

	// Creation option for etcd service.
	// ETCD snapshot S3 config
	S3Config []S3ConfigObservation `json:"s3Config,omitempty" tf:"s3_config,omitempty"`

	// ETCD snapshot retention.
	// ETCD snapshot retention
	SnapshotRetention *float64 `json:"snapshotRetention,omitempty" tf:"snapshot_retention,omitempty"`

	// ETCD snapshot schedule cron (e.g \"0 */5 * * *\").
	// ETCD snapshot schedule cron (e.g `"0 */5 * * *"`)
	SnapshotScheduleCron *string `json:"snapshotScheduleCron,omitempty" tf:"snapshot_schedule_cron,omitempty"`
}

type RkeConfigEtcdParameters struct {

	// Disable ETCD snapshots.
	// Disable ETCD snapshots
	// +kubebuilder:validation:Optional
	DisableSnapshots *bool `json:"disableSnapshots,omitempty" tf:"disable_snapshots,omitempty"`

	// Creation option for etcd service.
	// ETCD snapshot S3 config
	// +kubebuilder:validation:Optional
	S3Config []S3ConfigParameters `json:"s3Config,omitempty" tf:"s3_config,omitempty"`

	// ETCD snapshot retention.
	// ETCD snapshot retention
	// +kubebuilder:validation:Optional
	SnapshotRetention *float64 `json:"snapshotRetention,omitempty" tf:"snapshot_retention,omitempty"`

	// ETCD snapshot schedule cron (e.g \"0 */5 * * *\").
	// ETCD snapshot schedule cron (e.g `"0 */5 * * *"`)
	// +kubebuilder:validation:Optional
	SnapshotScheduleCron *string `json:"snapshotScheduleCron,omitempty" tf:"snapshot_schedule_cron,omitempty"`
}

type RkeConfigLocalAuthEndpointInitParameters struct {

	// CA certs for the authorized cluster endpoint. It is only needed if there is a load balancer in front of the downstream cluster that is using an untrusted certificate. If you have a valid certificate, then nothing needs to be added to the CA Certificates field.
	CACerts *string `json:"caCerts,omitempty" tf:"ca_certs,omitempty"`

	// Enable the authorized cluster endpoint.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// FQDN for the authorized cluster endpoint. If one is entered, it should point to the downstream cluster.
	Fqdn *string `json:"fqdn,omitempty" tf:"fqdn,omitempty"`
}

type RkeConfigLocalAuthEndpointObservation struct {

	// CA certs for the authorized cluster endpoint. It is only needed if there is a load balancer in front of the downstream cluster that is using an untrusted certificate. If you have a valid certificate, then nothing needs to be added to the CA Certificates field.
	CACerts *string `json:"caCerts,omitempty" tf:"ca_certs,omitempty"`

	// Enable the authorized cluster endpoint.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// FQDN for the authorized cluster endpoint. If one is entered, it should point to the downstream cluster.
	Fqdn *string `json:"fqdn,omitempty" tf:"fqdn,omitempty"`
}

type RkeConfigLocalAuthEndpointParameters struct {

	// CA certs for the authorized cluster endpoint. It is only needed if there is a load balancer in front of the downstream cluster that is using an untrusted certificate. If you have a valid certificate, then nothing needs to be added to the CA Certificates field.
	// +kubebuilder:validation:Optional
	CACerts *string `json:"caCerts,omitempty" tf:"ca_certs,omitempty"`

	// Enable the authorized cluster endpoint.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// FQDN for the authorized cluster endpoint. If one is entered, it should point to the downstream cluster.
	// +kubebuilder:validation:Optional
	Fqdn *string `json:"fqdn,omitempty" tf:"fqdn,omitempty"`
}

type RotateCertificatesInitParameters struct {

	// Desired certificate rotation generation.
	// Desired certificate rotation generation.
	Generation *float64 `json:"generation,omitempty" tf:"generation,omitempty"`

	// Service certificates to rotate with this generation.
	// Service certificates to rotate with this generation.
	Services []*string `json:"services,omitempty" tf:"services,omitempty"`
}

type RotateCertificatesObservation struct {

	// Desired certificate rotation generation.
	// Desired certificate rotation generation.
	Generation *float64 `json:"generation,omitempty" tf:"generation,omitempty"`

	// Service certificates to rotate with this generation.
	// Service certificates to rotate with this generation.
	Services []*string `json:"services,omitempty" tf:"services,omitempty"`
}

type RotateCertificatesParameters struct {

	// Desired certificate rotation generation.
	// Desired certificate rotation generation.
	// +kubebuilder:validation:Optional
	Generation *float64 `json:"generation" tf:"generation,omitempty"`

	// Service certificates to rotate with this generation.
	// Service certificates to rotate with this generation.
	// +kubebuilder:validation:Optional
	Services []*string `json:"services,omitempty" tf:"services,omitempty"`
}

type S3ConfigInitParameters struct {

	// Bucket name for S3 service.
	// ETCD snapshot S3 bucket
	Bucket *string `json:"bucket,omitempty" tf:"bucket,omitempty"`

	// ETCD snapshot S3 cloud credential name.
	// ETCD snapshot S3 cloud credential name
	CloudCredentialName *string `json:"cloudCredentialName,omitempty" tf:"cloud_credential_name,omitempty"`

	// ETCD snapshot S3 endpoint.
	// ETCD snapshot S3 endpoint
	Endpoint *string `json:"endpoint,omitempty" tf:"endpoint,omitempty"`

	// ETCD snapshot S3 endpoint CA.
	// ETCD snapshot S3 endpoint CA
	EndpointCA *string `json:"endpointCa,omitempty" tf:"endpoint_ca,omitempty"`

	// ETCD snapshot S3 folder.
	// ETCD snapshot S3 folder
	Folder *string `json:"folder,omitempty" tf:"folder,omitempty"`

	// ETCD snapshot S3 region.
	// ETCD snapshot S3 region
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// Disable ETCD skip ssl verify.
	// Disable ETCD skip ssl verify
	SkipSSLVerify *bool `json:"skipSslVerify,omitempty" tf:"skip_ssl_verify,omitempty"`
}

type S3ConfigObservation struct {

	// Bucket name for S3 service.
	// ETCD snapshot S3 bucket
	Bucket *string `json:"bucket,omitempty" tf:"bucket,omitempty"`

	// ETCD snapshot S3 cloud credential name.
	// ETCD snapshot S3 cloud credential name
	CloudCredentialName *string `json:"cloudCredentialName,omitempty" tf:"cloud_credential_name,omitempty"`

	// ETCD snapshot S3 endpoint.
	// ETCD snapshot S3 endpoint
	Endpoint *string `json:"endpoint,omitempty" tf:"endpoint,omitempty"`

	// ETCD snapshot S3 endpoint CA.
	// ETCD snapshot S3 endpoint CA
	EndpointCA *string `json:"endpointCa,omitempty" tf:"endpoint_ca,omitempty"`

	// ETCD snapshot S3 folder.
	// ETCD snapshot S3 folder
	Folder *string `json:"folder,omitempty" tf:"folder,omitempty"`

	// ETCD snapshot S3 region.
	// ETCD snapshot S3 region
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// Disable ETCD skip ssl verify.
	// Disable ETCD skip ssl verify
	SkipSSLVerify *bool `json:"skipSslVerify,omitempty" tf:"skip_ssl_verify,omitempty"`
}

type S3ConfigParameters struct {

	// Bucket name for S3 service.
	// ETCD snapshot S3 bucket
	// +kubebuilder:validation:Optional
	Bucket *string `json:"bucket" tf:"bucket,omitempty"`

	// ETCD snapshot S3 cloud credential name.
	// ETCD snapshot S3 cloud credential name
	// +kubebuilder:validation:Optional
	CloudCredentialName *string `json:"cloudCredentialName,omitempty" tf:"cloud_credential_name,omitempty"`

	// ETCD snapshot S3 endpoint.
	// ETCD snapshot S3 endpoint
	// +kubebuilder:validation:Optional
	Endpoint *string `json:"endpoint" tf:"endpoint,omitempty"`

	// ETCD snapshot S3 endpoint CA.
	// ETCD snapshot S3 endpoint CA
	// +kubebuilder:validation:Optional
	EndpointCA *string `json:"endpointCa,omitempty" tf:"endpoint_ca,omitempty"`

	// ETCD snapshot S3 folder.
	// ETCD snapshot S3 folder
	// +kubebuilder:validation:Optional
	Folder *string `json:"folder,omitempty" tf:"folder,omitempty"`

	// ETCD snapshot S3 region.
	// ETCD snapshot S3 region
	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// Disable ETCD skip ssl verify.
	// Disable ETCD skip ssl verify
	// +kubebuilder:validation:Optional
	SkipSSLVerify *bool `json:"skipSslVerify,omitempty" tf:"skip_ssl_verify,omitempty"`
}

type SchedulingCustomizationPodDisruptionBudgetInitParameters struct {

	// The maximum number of agent replicas that can be unavailable at a given time. This can be a non-negative whole number or a whole number percentage (e.g. "1", "50%"). This field cannot be used at the same time as min_available.
	// The maximum number of cattle cluster agent replicas that can be down at a given time.
	MaxUnavailable *string `json:"maxUnavailable,omitempty" tf:"max_unavailable,omitempty"`

	// The minimum number of agent replicas that must be running at a given time. This can be a non-negative whole number or a whole number percentage (e.g. "1", "50%"). This field cannot be used at the same time as max_unavailable.
	// The minimum number of cattle cluster agent replicas that must be running at a given time.
	MinAvailable *string `json:"minAvailable,omitempty" tf:"min_available,omitempty"`
}

type SchedulingCustomizationPodDisruptionBudgetObservation struct {

	// The maximum number of agent replicas that can be unavailable at a given time. This can be a non-negative whole number or a whole number percentage (e.g. "1", "50%"). This field cannot be used at the same time as min_available.
	// The maximum number of cattle cluster agent replicas that can be down at a given time.
	MaxUnavailable *string `json:"maxUnavailable,omitempty" tf:"max_unavailable,omitempty"`

	// The minimum number of agent replicas that must be running at a given time. This can be a non-negative whole number or a whole number percentage (e.g. "1", "50%"). This field cannot be used at the same time as max_unavailable.
	// The minimum number of cattle cluster agent replicas that must be running at a given time.
	MinAvailable *string `json:"minAvailable,omitempty" tf:"min_available,omitempty"`
}

type SchedulingCustomizationPodDisruptionBudgetParameters struct {

	// The maximum number of agent replicas that can be unavailable at a given time. This can be a non-negative whole number or a whole number percentage (e.g. "1", "50%"). This field cannot be used at the same time as min_available.
	// The maximum number of cattle cluster agent replicas that can be down at a given time.
	// +kubebuilder:validation:Optional
	MaxUnavailable *string `json:"maxUnavailable,omitempty" tf:"max_unavailable,omitempty"`

	// The minimum number of agent replicas that must be running at a given time. This can be a non-negative whole number or a whole number percentage (e.g. "1", "50%"). This field cannot be used at the same time as max_unavailable.
	// The minimum number of cattle cluster agent replicas that must be running at a given time.
	// +kubebuilder:validation:Optional
	MinAvailable *string `json:"minAvailable,omitempty" tf:"min_available,omitempty"`
}

type SchedulingCustomizationPriorityClassInitParameters struct {

	// The preemption policy set for the Priority Class. Must be set to either 'Never', 'PreemptLowerPriority', or omitted.
	// The preemption behavior for the cattle cluster agent. Must be either 'PreemptLowerPriority' or 'Never'
	PreemptionPolicy *string `json:"preemptionPolicy,omitempty" tf:"preemption_policy,omitempty"`

	// Rancher agent env var value.
	// The priority value for the cattle cluster agent. Must be between negative 1 billion and 1 billion.
	Value *float64 `json:"value,omitempty" tf:"value,omitempty"`
}

type SchedulingCustomizationPriorityClassObservation struct {

	// The preemption policy set for the Priority Class. Must be set to either 'Never', 'PreemptLowerPriority', or omitted.
	// The preemption behavior for the cattle cluster agent. Must be either 'PreemptLowerPriority' or 'Never'
	PreemptionPolicy *string `json:"preemptionPolicy,omitempty" tf:"preemption_policy,omitempty"`

	// Rancher agent env var value.
	// The priority value for the cattle cluster agent. Must be between negative 1 billion and 1 billion.
	Value *float64 `json:"value,omitempty" tf:"value,omitempty"`
}

type SchedulingCustomizationPriorityClassParameters struct {

	// The preemption policy set for the Priority Class. Must be set to either 'Never', 'PreemptLowerPriority', or omitted.
	// The preemption behavior for the cattle cluster agent. Must be either 'PreemptLowerPriority' or 'Never'
	// +kubebuilder:validation:Optional
	PreemptionPolicy *string `json:"preemptionPolicy,omitempty" tf:"preemption_policy,omitempty"`

	// Rancher agent env var value.
	// The priority value for the cattle cluster agent. Must be between negative 1 billion and 1 billion.
	// +kubebuilder:validation:Optional
	Value *float64 `json:"value" tf:"value,omitempty"`
}

type SecretInitParameters struct {

	// The numeric representation of the default file permissions for all files defined under the items.
	// The default permissions to be applied when they are not set at the item level
	DefaultPermissions *string `json:"defaultPermissions,omitempty" tf:"default_permissions,omitempty"`

	// Items is a list of configurations for files, such as where to retrieve the content from the source, where to put the file on nodes, and etc.
	// Items(files) to retrieve from the K8s object
	Items []SecretItemsInitParameters `json:"items,omitempty" tf:"items,omitempty"`

	// The name of the cluster.
	// The name of the K8s object
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type SecretItemsInitParameters struct {

	// If true, the file is ignored when determining whether the node should be drained before updating the node plan.
	// If ture, the file is ignored when determining whether the node should be drained before updating the node plan (default: true).
	Dynamic *bool `json:"dynamic,omitempty" tf:"dynamic,omitempty"`

	// Hash is the base64 encoded value of the SHA256 checksum of the file's content. If specified, it is used to validate the integrity of the file content.
	// The base64 encoded value of the SHA256 checksum of the file's content
	Hash *string `json:"hash,omitempty" tf:"hash,omitempty"`

	// The toleration key.
	// The key of the item(file) to retrieve
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// Path is the absolute path to put the file in the target node.
	// The path to put the file in the target node
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// Permissions is the numeric representation of the file permission. It takes precedence over the default permissions at the outer level.
	// The numeric representation of the file permissions
	Permissions *string `json:"permissions,omitempty" tf:"permissions,omitempty"`
}

type SecretItemsObservation struct {

	// If true, the file is ignored when determining whether the node should be drained before updating the node plan.
	// If ture, the file is ignored when determining whether the node should be drained before updating the node plan (default: true).
	Dynamic *bool `json:"dynamic,omitempty" tf:"dynamic,omitempty"`

	// Hash is the base64 encoded value of the SHA256 checksum of the file's content. If specified, it is used to validate the integrity of the file content.
	// The base64 encoded value of the SHA256 checksum of the file's content
	Hash *string `json:"hash,omitempty" tf:"hash,omitempty"`

	// The toleration key.
	// The key of the item(file) to retrieve
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// Path is the absolute path to put the file in the target node.
	// The path to put the file in the target node
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// Permissions is the numeric representation of the file permission. It takes precedence over the default permissions at the outer level.
	// The numeric representation of the file permissions
	Permissions *string `json:"permissions,omitempty" tf:"permissions,omitempty"`
}

type SecretItemsParameters struct {

	// If true, the file is ignored when determining whether the node should be drained before updating the node plan.
	// If ture, the file is ignored when determining whether the node should be drained before updating the node plan (default: true).
	// +kubebuilder:validation:Optional
	Dynamic *bool `json:"dynamic,omitempty" tf:"dynamic,omitempty"`

	// Hash is the base64 encoded value of the SHA256 checksum of the file's content. If specified, it is used to validate the integrity of the file content.
	// The base64 encoded value of the SHA256 checksum of the file's content
	// +kubebuilder:validation:Optional
	Hash *string `json:"hash,omitempty" tf:"hash,omitempty"`

	// The toleration key.
	// The key of the item(file) to retrieve
	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`

	// Path is the absolute path to put the file in the target node.
	// The path to put the file in the target node
	// +kubebuilder:validation:Optional
	Path *string `json:"path" tf:"path,omitempty"`

	// Permissions is the numeric representation of the file permission. It takes precedence over the default permissions at the outer level.
	// The numeric representation of the file permissions
	// +kubebuilder:validation:Optional
	Permissions *string `json:"permissions,omitempty" tf:"permissions,omitempty"`
}

type SecretObservation struct {

	// The numeric representation of the default file permissions for all files defined under the items.
	// The default permissions to be applied when they are not set at the item level
	DefaultPermissions *string `json:"defaultPermissions,omitempty" tf:"default_permissions,omitempty"`

	// Items is a list of configurations for files, such as where to retrieve the content from the source, where to put the file on nodes, and etc.
	// Items(files) to retrieve from the K8s object
	Items []SecretItemsObservation `json:"items,omitempty" tf:"items,omitempty"`

	// The name of the cluster.
	// The name of the K8s object
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type SecretParameters struct {

	// The numeric representation of the default file permissions for all files defined under the items.
	// The default permissions to be applied when they are not set at the item level
	// +kubebuilder:validation:Optional
	DefaultPermissions *string `json:"defaultPermissions,omitempty" tf:"default_permissions,omitempty"`

	// Items is a list of configurations for files, such as where to retrieve the content from the source, where to put the file on nodes, and etc.
	// Items(files) to retrieve from the K8s object
	// +kubebuilder:validation:Optional
	Items []SecretItemsParameters `json:"items,omitempty" tf:"items,omitempty"`

	// The name of the cluster.
	// The name of the K8s object
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`
}

type WorkerDrainOptionsInitParameters struct {

	// if delete_empty_dir_data is set to true, continue draining even if there are pods using emptyDir (local storage).
	// Drain options delete empty dir data
	DeleteEmptyDirData *bool `json:"deleteEmptyDirData,omitempty" tf:"delete_empty_dir_data,omitempty"`

	// If disable_eviction is set to true, force drain to use delete rather than evict.
	// Drain options disable eviction
	DisableEviction *bool `json:"disableEviction,omitempty" tf:"disable_eviction,omitempty"`

	// Enable the authorized cluster endpoint.
	// Drain options enabled?
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// If force is set to true, drain nodes even if there are standalone pods that are not managed by a ReplicationController, Job, or DaemonSet. Drain will not proceed without force set to true if there are such pods.
	// Drain options force
	Force *bool `json:"force,omitempty" tf:"force,omitempty"`

	// Time in seconds given to each pod to terminate gracefully. If negative, the default value specified in the pod will be used.
	// Drain options grace period
	GracePeriod *float64 `json:"gracePeriod,omitempty" tf:"grace_period,omitempty"`

	// If ignore_daemon_sets is set to false, drain will not proceed if there are DaemonSet-managed pods.
	// Drain options ignore daemon sets
	IgnoreDaemonSets *bool `json:"ignoreDaemonSets,omitempty" tf:"ignore_daemon_sets,omitempty"`

	// If ignore_errors is set to true,  errors that occurred between drain nodes in group are ignored.
	// Drain options ignore errors
	IgnoreErrors *bool `json:"ignoreErrors,omitempty" tf:"ignore_errors,omitempty"`

	// Skip waiting for the pods that have a DeletionTimeStamp > N seconds to be deleted. Seconds must be greater than 0 to skip. Such pods will be force deleted.
	// Drain options skip wait for delete timeout seconds
	SkipWaitForDeleteTimeoutSeconds *float64 `json:"skipWaitForDeleteTimeoutSeconds,omitempty" tf:"skip_wait_for_delete_timeout_seconds,omitempty"`

	// Time to wait (in seconds) before giving up for one try.
	// Drain options timeout
	Timeout *float64 `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

type WorkerDrainOptionsObservation struct {

	// if delete_empty_dir_data is set to true, continue draining even if there are pods using emptyDir (local storage).
	// Drain options delete empty dir data
	DeleteEmptyDirData *bool `json:"deleteEmptyDirData,omitempty" tf:"delete_empty_dir_data,omitempty"`

	// If disable_eviction is set to true, force drain to use delete rather than evict.
	// Drain options disable eviction
	DisableEviction *bool `json:"disableEviction,omitempty" tf:"disable_eviction,omitempty"`

	// Enable the authorized cluster endpoint.
	// Drain options enabled?
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// If force is set to true, drain nodes even if there are standalone pods that are not managed by a ReplicationController, Job, or DaemonSet. Drain will not proceed without force set to true if there are such pods.
	// Drain options force
	Force *bool `json:"force,omitempty" tf:"force,omitempty"`

	// Time in seconds given to each pod to terminate gracefully. If negative, the default value specified in the pod will be used.
	// Drain options grace period
	GracePeriod *float64 `json:"gracePeriod,omitempty" tf:"grace_period,omitempty"`

	// If ignore_daemon_sets is set to false, drain will not proceed if there are DaemonSet-managed pods.
	// Drain options ignore daemon sets
	IgnoreDaemonSets *bool `json:"ignoreDaemonSets,omitempty" tf:"ignore_daemon_sets,omitempty"`

	// If ignore_errors is set to true,  errors that occurred between drain nodes in group are ignored.
	// Drain options ignore errors
	IgnoreErrors *bool `json:"ignoreErrors,omitempty" tf:"ignore_errors,omitempty"`

	// Skip waiting for the pods that have a DeletionTimeStamp > N seconds to be deleted. Seconds must be greater than 0 to skip. Such pods will be force deleted.
	// Drain options skip wait for delete timeout seconds
	SkipWaitForDeleteTimeoutSeconds *float64 `json:"skipWaitForDeleteTimeoutSeconds,omitempty" tf:"skip_wait_for_delete_timeout_seconds,omitempty"`

	// Time to wait (in seconds) before giving up for one try.
	// Drain options timeout
	Timeout *float64 `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

type WorkerDrainOptionsParameters struct {

	// if delete_empty_dir_data is set to true, continue draining even if there are pods using emptyDir (local storage).
	// Drain options delete empty dir data
	// +kubebuilder:validation:Optional
	DeleteEmptyDirData *bool `json:"deleteEmptyDirData,omitempty" tf:"delete_empty_dir_data,omitempty"`

	// If disable_eviction is set to true, force drain to use delete rather than evict.
	// Drain options disable eviction
	// +kubebuilder:validation:Optional
	DisableEviction *bool `json:"disableEviction,omitempty" tf:"disable_eviction,omitempty"`

	// Enable the authorized cluster endpoint.
	// Drain options enabled?
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// If force is set to true, drain nodes even if there are standalone pods that are not managed by a ReplicationController, Job, or DaemonSet. Drain will not proceed without force set to true if there are such pods.
	// Drain options force
	// +kubebuilder:validation:Optional
	Force *bool `json:"force,omitempty" tf:"force,omitempty"`

	// Time in seconds given to each pod to terminate gracefully. If negative, the default value specified in the pod will be used.
	// Drain options grace period
	// +kubebuilder:validation:Optional
	GracePeriod *float64 `json:"gracePeriod,omitempty" tf:"grace_period,omitempty"`

	// If ignore_daemon_sets is set to false, drain will not proceed if there are DaemonSet-managed pods.
	// Drain options ignore daemon sets
	// +kubebuilder:validation:Optional
	IgnoreDaemonSets *bool `json:"ignoreDaemonSets,omitempty" tf:"ignore_daemon_sets,omitempty"`

	// If ignore_errors is set to true,  errors that occurred between drain nodes in group are ignored.
	// Drain options ignore errors
	// +kubebuilder:validation:Optional
	IgnoreErrors *bool `json:"ignoreErrors,omitempty" tf:"ignore_errors,omitempty"`

	// Skip waiting for the pods that have a DeletionTimeStamp > N seconds to be deleted. Seconds must be greater than 0 to skip. Such pods will be force deleted.
	// Drain options skip wait for delete timeout seconds
	// +kubebuilder:validation:Optional
	SkipWaitForDeleteTimeoutSeconds *float64 `json:"skipWaitForDeleteTimeoutSeconds,omitempty" tf:"skip_wait_for_delete_timeout_seconds,omitempty"`

	// Time to wait (in seconds) before giving up for one try.
	// Drain options timeout
	// +kubebuilder:validation:Optional
	Timeout *float64 `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

// ClusterV2Spec defines the desired state of ClusterV2
type ClusterV2Spec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ClusterV2Parameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider ClusterV2InitParameters `json:"initProvider,omitempty"`
}

// ClusterV2Status defines the observed state of ClusterV2.
type ClusterV2Status struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ClusterV2Observation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// ClusterV2 is the Schema for the ClusterV2s API. Provides a Rancher v2 Cluster v2 resource. This can be used to create node-driver and custom RKE2 and K3s Clusters for Rancher v2 environments and retrieve their information.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,rancher2}
type ClusterV2 struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.kubernetesVersion) || (has(self.initProvider) && has(self.initProvider.kubernetesVersion))",message="spec.forProvider.kubernetesVersion is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	Spec   ClusterV2Spec   `json:"spec"`
	Status ClusterV2Status `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ClusterV2List contains a list of ClusterV2s
type ClusterV2List struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ClusterV2 `json:"items"`
}

// Repository type metadata.
var (
	ClusterV2_Kind             = "ClusterV2"
	ClusterV2_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: ClusterV2_Kind}.String()
	ClusterV2_KindAPIVersion   = ClusterV2_Kind + "." + CRDGroupVersion.String()
	ClusterV2_GroupVersionKind = CRDGroupVersion.WithKind(ClusterV2_Kind)
)

func init() {
	SchemeBuilder.Register(&ClusterV2{}, &ClusterV2List{})
}
