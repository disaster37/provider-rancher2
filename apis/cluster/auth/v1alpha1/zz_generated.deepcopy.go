//go:build !ignore_autogenerated

// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
	"github.com/crossplane/crossplane-runtime/v2/apis/common/v1"
	runtime "k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigActivedirectory) DeepCopyInto(out *AuthConfigActivedirectory) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigActivedirectory.
func (in *AuthConfigActivedirectory) DeepCopy() *AuthConfigActivedirectory {
	if in == nil {
		return nil
	}
	out := new(AuthConfigActivedirectory)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AuthConfigActivedirectory) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigActivedirectoryInitParameters) DeepCopyInto(out *AuthConfigActivedirectoryInitParameters) {
	*out = *in
	if in.AccessMode != nil {
		in, out := &in.AccessMode, &out.AccessMode
		*out = new(string)
		**out = **in
	}
	if in.AllowedPrincipalIds != nil {
		in, out := &in.AllowedPrincipalIds, &out.AllowedPrincipalIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.CertificateSecretRef != nil {
		in, out := &in.CertificateSecretRef, &out.CertificateSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.ConnectionTimeout != nil {
		in, out := &in.ConnectionTimeout, &out.ConnectionTimeout
		*out = new(float64)
		**out = **in
	}
	if in.DefaultLoginDomain != nil {
		in, out := &in.DefaultLoginDomain, &out.DefaultLoginDomain
		*out = new(string)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.GroupDnAttribute != nil {
		in, out := &in.GroupDnAttribute, &out.GroupDnAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupMemberMappingAttribute != nil {
		in, out := &in.GroupMemberMappingAttribute, &out.GroupMemberMappingAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupMemberUserAttribute != nil {
		in, out := &in.GroupMemberUserAttribute, &out.GroupMemberUserAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupNameAttribute != nil {
		in, out := &in.GroupNameAttribute, &out.GroupNameAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupObjectClass != nil {
		in, out := &in.GroupObjectClass, &out.GroupObjectClass
		*out = new(string)
		**out = **in
	}
	if in.GroupSearchAttribute != nil {
		in, out := &in.GroupSearchAttribute, &out.GroupSearchAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupSearchBase != nil {
		in, out := &in.GroupSearchBase, &out.GroupSearchBase
		*out = new(string)
		**out = **in
	}
	if in.GroupSearchFilter != nil {
		in, out := &in.GroupSearchFilter, &out.GroupSearchFilter
		*out = new(string)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.NestedGroupMembershipEnabled != nil {
		in, out := &in.NestedGroupMembershipEnabled, &out.NestedGroupMembershipEnabled
		*out = new(bool)
		**out = **in
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(float64)
		**out = **in
	}
	if in.Servers != nil {
		in, out := &in.Servers, &out.Servers
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	in.ServiceAccountPasswordSecretRef.DeepCopyInto(&out.ServiceAccountPasswordSecretRef)
	in.ServiceAccountUsernameSecretRef.DeepCopyInto(&out.ServiceAccountUsernameSecretRef)
	if in.StartTLS != nil {
		in, out := &in.StartTLS, &out.StartTLS
		*out = new(bool)
		**out = **in
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(bool)
		**out = **in
	}
	in.TestPasswordSecretRef.DeepCopyInto(&out.TestPasswordSecretRef)
	if in.TestUsername != nil {
		in, out := &in.TestUsername, &out.TestUsername
		*out = new(string)
		**out = **in
	}
	if in.UserDisabledBitMask != nil {
		in, out := &in.UserDisabledBitMask, &out.UserDisabledBitMask
		*out = new(float64)
		**out = **in
	}
	if in.UserEnabledAttribute != nil {
		in, out := &in.UserEnabledAttribute, &out.UserEnabledAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserLoginAttribute != nil {
		in, out := &in.UserLoginAttribute, &out.UserLoginAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserNameAttribute != nil {
		in, out := &in.UserNameAttribute, &out.UserNameAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserObjectClass != nil {
		in, out := &in.UserObjectClass, &out.UserObjectClass
		*out = new(string)
		**out = **in
	}
	if in.UserSearchAttribute != nil {
		in, out := &in.UserSearchAttribute, &out.UserSearchAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserSearchBase != nil {
		in, out := &in.UserSearchBase, &out.UserSearchBase
		*out = new(string)
		**out = **in
	}
	if in.UserSearchFilter != nil {
		in, out := &in.UserSearchFilter, &out.UserSearchFilter
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigActivedirectoryInitParameters.
func (in *AuthConfigActivedirectoryInitParameters) DeepCopy() *AuthConfigActivedirectoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(AuthConfigActivedirectoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigActivedirectoryList) DeepCopyInto(out *AuthConfigActivedirectoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]AuthConfigActivedirectory, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigActivedirectoryList.
func (in *AuthConfigActivedirectoryList) DeepCopy() *AuthConfigActivedirectoryList {
	if in == nil {
		return nil
	}
	out := new(AuthConfigActivedirectoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AuthConfigActivedirectoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigActivedirectoryObservation) DeepCopyInto(out *AuthConfigActivedirectoryObservation) {
	*out = *in
	if in.AccessMode != nil {
		in, out := &in.AccessMode, &out.AccessMode
		*out = new(string)
		**out = **in
	}
	if in.AllowedPrincipalIds != nil {
		in, out := &in.AllowedPrincipalIds, &out.AllowedPrincipalIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.ConnectionTimeout != nil {
		in, out := &in.ConnectionTimeout, &out.ConnectionTimeout
		*out = new(float64)
		**out = **in
	}
	if in.DefaultLoginDomain != nil {
		in, out := &in.DefaultLoginDomain, &out.DefaultLoginDomain
		*out = new(string)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.GroupDnAttribute != nil {
		in, out := &in.GroupDnAttribute, &out.GroupDnAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupMemberMappingAttribute != nil {
		in, out := &in.GroupMemberMappingAttribute, &out.GroupMemberMappingAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupMemberUserAttribute != nil {
		in, out := &in.GroupMemberUserAttribute, &out.GroupMemberUserAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupNameAttribute != nil {
		in, out := &in.GroupNameAttribute, &out.GroupNameAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupObjectClass != nil {
		in, out := &in.GroupObjectClass, &out.GroupObjectClass
		*out = new(string)
		**out = **in
	}
	if in.GroupSearchAttribute != nil {
		in, out := &in.GroupSearchAttribute, &out.GroupSearchAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupSearchBase != nil {
		in, out := &in.GroupSearchBase, &out.GroupSearchBase
		*out = new(string)
		**out = **in
	}
	if in.GroupSearchFilter != nil {
		in, out := &in.GroupSearchFilter, &out.GroupSearchFilter
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.NestedGroupMembershipEnabled != nil {
		in, out := &in.NestedGroupMembershipEnabled, &out.NestedGroupMembershipEnabled
		*out = new(bool)
		**out = **in
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(float64)
		**out = **in
	}
	if in.Servers != nil {
		in, out := &in.Servers, &out.Servers
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.StartTLS != nil {
		in, out := &in.StartTLS, &out.StartTLS
		*out = new(bool)
		**out = **in
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(bool)
		**out = **in
	}
	if in.TestUsername != nil {
		in, out := &in.TestUsername, &out.TestUsername
		*out = new(string)
		**out = **in
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
	if in.UserDisabledBitMask != nil {
		in, out := &in.UserDisabledBitMask, &out.UserDisabledBitMask
		*out = new(float64)
		**out = **in
	}
	if in.UserEnabledAttribute != nil {
		in, out := &in.UserEnabledAttribute, &out.UserEnabledAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserLoginAttribute != nil {
		in, out := &in.UserLoginAttribute, &out.UserLoginAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserNameAttribute != nil {
		in, out := &in.UserNameAttribute, &out.UserNameAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserObjectClass != nil {
		in, out := &in.UserObjectClass, &out.UserObjectClass
		*out = new(string)
		**out = **in
	}
	if in.UserSearchAttribute != nil {
		in, out := &in.UserSearchAttribute, &out.UserSearchAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserSearchBase != nil {
		in, out := &in.UserSearchBase, &out.UserSearchBase
		*out = new(string)
		**out = **in
	}
	if in.UserSearchFilter != nil {
		in, out := &in.UserSearchFilter, &out.UserSearchFilter
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigActivedirectoryObservation.
func (in *AuthConfigActivedirectoryObservation) DeepCopy() *AuthConfigActivedirectoryObservation {
	if in == nil {
		return nil
	}
	out := new(AuthConfigActivedirectoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigActivedirectoryParameters) DeepCopyInto(out *AuthConfigActivedirectoryParameters) {
	*out = *in
	if in.AccessMode != nil {
		in, out := &in.AccessMode, &out.AccessMode
		*out = new(string)
		**out = **in
	}
	if in.AllowedPrincipalIds != nil {
		in, out := &in.AllowedPrincipalIds, &out.AllowedPrincipalIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.CertificateSecretRef != nil {
		in, out := &in.CertificateSecretRef, &out.CertificateSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.ConnectionTimeout != nil {
		in, out := &in.ConnectionTimeout, &out.ConnectionTimeout
		*out = new(float64)
		**out = **in
	}
	if in.DefaultLoginDomain != nil {
		in, out := &in.DefaultLoginDomain, &out.DefaultLoginDomain
		*out = new(string)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.GroupDnAttribute != nil {
		in, out := &in.GroupDnAttribute, &out.GroupDnAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupMemberMappingAttribute != nil {
		in, out := &in.GroupMemberMappingAttribute, &out.GroupMemberMappingAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupMemberUserAttribute != nil {
		in, out := &in.GroupMemberUserAttribute, &out.GroupMemberUserAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupNameAttribute != nil {
		in, out := &in.GroupNameAttribute, &out.GroupNameAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupObjectClass != nil {
		in, out := &in.GroupObjectClass, &out.GroupObjectClass
		*out = new(string)
		**out = **in
	}
	if in.GroupSearchAttribute != nil {
		in, out := &in.GroupSearchAttribute, &out.GroupSearchAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupSearchBase != nil {
		in, out := &in.GroupSearchBase, &out.GroupSearchBase
		*out = new(string)
		**out = **in
	}
	if in.GroupSearchFilter != nil {
		in, out := &in.GroupSearchFilter, &out.GroupSearchFilter
		*out = new(string)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.NestedGroupMembershipEnabled != nil {
		in, out := &in.NestedGroupMembershipEnabled, &out.NestedGroupMembershipEnabled
		*out = new(bool)
		**out = **in
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(float64)
		**out = **in
	}
	if in.Servers != nil {
		in, out := &in.Servers, &out.Servers
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	in.ServiceAccountPasswordSecretRef.DeepCopyInto(&out.ServiceAccountPasswordSecretRef)
	in.ServiceAccountUsernameSecretRef.DeepCopyInto(&out.ServiceAccountUsernameSecretRef)
	if in.StartTLS != nil {
		in, out := &in.StartTLS, &out.StartTLS
		*out = new(bool)
		**out = **in
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(bool)
		**out = **in
	}
	in.TestPasswordSecretRef.DeepCopyInto(&out.TestPasswordSecretRef)
	if in.TestUsername != nil {
		in, out := &in.TestUsername, &out.TestUsername
		*out = new(string)
		**out = **in
	}
	if in.UserDisabledBitMask != nil {
		in, out := &in.UserDisabledBitMask, &out.UserDisabledBitMask
		*out = new(float64)
		**out = **in
	}
	if in.UserEnabledAttribute != nil {
		in, out := &in.UserEnabledAttribute, &out.UserEnabledAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserLoginAttribute != nil {
		in, out := &in.UserLoginAttribute, &out.UserLoginAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserNameAttribute != nil {
		in, out := &in.UserNameAttribute, &out.UserNameAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserObjectClass != nil {
		in, out := &in.UserObjectClass, &out.UserObjectClass
		*out = new(string)
		**out = **in
	}
	if in.UserSearchAttribute != nil {
		in, out := &in.UserSearchAttribute, &out.UserSearchAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserSearchBase != nil {
		in, out := &in.UserSearchBase, &out.UserSearchBase
		*out = new(string)
		**out = **in
	}
	if in.UserSearchFilter != nil {
		in, out := &in.UserSearchFilter, &out.UserSearchFilter
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigActivedirectoryParameters.
func (in *AuthConfigActivedirectoryParameters) DeepCopy() *AuthConfigActivedirectoryParameters {
	if in == nil {
		return nil
	}
	out := new(AuthConfigActivedirectoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigActivedirectorySpec) DeepCopyInto(out *AuthConfigActivedirectorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigActivedirectorySpec.
func (in *AuthConfigActivedirectorySpec) DeepCopy() *AuthConfigActivedirectorySpec {
	if in == nil {
		return nil
	}
	out := new(AuthConfigActivedirectorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigActivedirectoryStatus) DeepCopyInto(out *AuthConfigActivedirectoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigActivedirectoryStatus.
func (in *AuthConfigActivedirectoryStatus) DeepCopy() *AuthConfigActivedirectoryStatus {
	if in == nil {
		return nil
	}
	out := new(AuthConfigActivedirectoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigAdfs) DeepCopyInto(out *AuthConfigAdfs) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigAdfs.
func (in *AuthConfigAdfs) DeepCopy() *AuthConfigAdfs {
	if in == nil {
		return nil
	}
	out := new(AuthConfigAdfs)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AuthConfigAdfs) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigAdfsInitParameters) DeepCopyInto(out *AuthConfigAdfsInitParameters) {
	*out = *in
	if in.AccessMode != nil {
		in, out := &in.AccessMode, &out.AccessMode
		*out = new(string)
		**out = **in
	}
	if in.AllowedPrincipalIds != nil {
		in, out := &in.AllowedPrincipalIds, &out.AllowedPrincipalIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DisplayNameField != nil {
		in, out := &in.DisplayNameField, &out.DisplayNameField
		*out = new(string)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.GroupsField != nil {
		in, out := &in.GroupsField, &out.GroupsField
		*out = new(string)
		**out = **in
	}
	in.IdpMetadataContentSecretRef.DeepCopyInto(&out.IdpMetadataContentSecretRef)
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.RancherAPIHost != nil {
		in, out := &in.RancherAPIHost, &out.RancherAPIHost
		*out = new(string)
		**out = **in
	}
	in.SpCertSecretRef.DeepCopyInto(&out.SpCertSecretRef)
	in.SpKeySecretRef.DeepCopyInto(&out.SpKeySecretRef)
	if in.UIDField != nil {
		in, out := &in.UIDField, &out.UIDField
		*out = new(string)
		**out = **in
	}
	if in.UserNameField != nil {
		in, out := &in.UserNameField, &out.UserNameField
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigAdfsInitParameters.
func (in *AuthConfigAdfsInitParameters) DeepCopy() *AuthConfigAdfsInitParameters {
	if in == nil {
		return nil
	}
	out := new(AuthConfigAdfsInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigAdfsList) DeepCopyInto(out *AuthConfigAdfsList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]AuthConfigAdfs, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigAdfsList.
func (in *AuthConfigAdfsList) DeepCopy() *AuthConfigAdfsList {
	if in == nil {
		return nil
	}
	out := new(AuthConfigAdfsList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AuthConfigAdfsList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigAdfsObservation) DeepCopyInto(out *AuthConfigAdfsObservation) {
	*out = *in
	if in.AccessMode != nil {
		in, out := &in.AccessMode, &out.AccessMode
		*out = new(string)
		**out = **in
	}
	if in.AllowedPrincipalIds != nil {
		in, out := &in.AllowedPrincipalIds, &out.AllowedPrincipalIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DisplayNameField != nil {
		in, out := &in.DisplayNameField, &out.DisplayNameField
		*out = new(string)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.GroupsField != nil {
		in, out := &in.GroupsField, &out.GroupsField
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.RancherAPIHost != nil {
		in, out := &in.RancherAPIHost, &out.RancherAPIHost
		*out = new(string)
		**out = **in
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
	if in.UIDField != nil {
		in, out := &in.UIDField, &out.UIDField
		*out = new(string)
		**out = **in
	}
	if in.UserNameField != nil {
		in, out := &in.UserNameField, &out.UserNameField
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigAdfsObservation.
func (in *AuthConfigAdfsObservation) DeepCopy() *AuthConfigAdfsObservation {
	if in == nil {
		return nil
	}
	out := new(AuthConfigAdfsObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigAdfsParameters) DeepCopyInto(out *AuthConfigAdfsParameters) {
	*out = *in
	if in.AccessMode != nil {
		in, out := &in.AccessMode, &out.AccessMode
		*out = new(string)
		**out = **in
	}
	if in.AllowedPrincipalIds != nil {
		in, out := &in.AllowedPrincipalIds, &out.AllowedPrincipalIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DisplayNameField != nil {
		in, out := &in.DisplayNameField, &out.DisplayNameField
		*out = new(string)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.GroupsField != nil {
		in, out := &in.GroupsField, &out.GroupsField
		*out = new(string)
		**out = **in
	}
	in.IdpMetadataContentSecretRef.DeepCopyInto(&out.IdpMetadataContentSecretRef)
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.RancherAPIHost != nil {
		in, out := &in.RancherAPIHost, &out.RancherAPIHost
		*out = new(string)
		**out = **in
	}
	in.SpCertSecretRef.DeepCopyInto(&out.SpCertSecretRef)
	in.SpKeySecretRef.DeepCopyInto(&out.SpKeySecretRef)
	if in.UIDField != nil {
		in, out := &in.UIDField, &out.UIDField
		*out = new(string)
		**out = **in
	}
	if in.UserNameField != nil {
		in, out := &in.UserNameField, &out.UserNameField
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigAdfsParameters.
func (in *AuthConfigAdfsParameters) DeepCopy() *AuthConfigAdfsParameters {
	if in == nil {
		return nil
	}
	out := new(AuthConfigAdfsParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigAdfsSpec) DeepCopyInto(out *AuthConfigAdfsSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigAdfsSpec.
func (in *AuthConfigAdfsSpec) DeepCopy() *AuthConfigAdfsSpec {
	if in == nil {
		return nil
	}
	out := new(AuthConfigAdfsSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigAdfsStatus) DeepCopyInto(out *AuthConfigAdfsStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigAdfsStatus.
func (in *AuthConfigAdfsStatus) DeepCopy() *AuthConfigAdfsStatus {
	if in == nil {
		return nil
	}
	out := new(AuthConfigAdfsStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigAzuread) DeepCopyInto(out *AuthConfigAzuread) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigAzuread.
func (in *AuthConfigAzuread) DeepCopy() *AuthConfigAzuread {
	if in == nil {
		return nil
	}
	out := new(AuthConfigAzuread)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AuthConfigAzuread) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigAzureadInitParameters) DeepCopyInto(out *AuthConfigAzureadInitParameters) {
	*out = *in
	if in.AccessMode != nil {
		in, out := &in.AccessMode, &out.AccessMode
		*out = new(string)
		**out = **in
	}
	if in.AllowedPrincipalIds != nil {
		in, out := &in.AllowedPrincipalIds, &out.AllowedPrincipalIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	in.ApplicationIDSecretRef.DeepCopyInto(&out.ApplicationIDSecretRef)
	in.ApplicationSecretSecretRef.DeepCopyInto(&out.ApplicationSecretSecretRef)
	if in.AuthEndpoint != nil {
		in, out := &in.AuthEndpoint, &out.AuthEndpoint
		*out = new(string)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.Endpoint != nil {
		in, out := &in.Endpoint, &out.Endpoint
		*out = new(string)
		**out = **in
	}
	if in.GraphEndpoint != nil {
		in, out := &in.GraphEndpoint, &out.GraphEndpoint
		*out = new(string)
		**out = **in
	}
	if in.GroupMembershipFilter != nil {
		in, out := &in.GroupMembershipFilter, &out.GroupMembershipFilter
		*out = new(string)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.RancherURL != nil {
		in, out := &in.RancherURL, &out.RancherURL
		*out = new(string)
		**out = **in
	}
	if in.TenantID != nil {
		in, out := &in.TenantID, &out.TenantID
		*out = new(string)
		**out = **in
	}
	if in.TokenEndpoint != nil {
		in, out := &in.TokenEndpoint, &out.TokenEndpoint
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigAzureadInitParameters.
func (in *AuthConfigAzureadInitParameters) DeepCopy() *AuthConfigAzureadInitParameters {
	if in == nil {
		return nil
	}
	out := new(AuthConfigAzureadInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigAzureadList) DeepCopyInto(out *AuthConfigAzureadList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]AuthConfigAzuread, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigAzureadList.
func (in *AuthConfigAzureadList) DeepCopy() *AuthConfigAzureadList {
	if in == nil {
		return nil
	}
	out := new(AuthConfigAzureadList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AuthConfigAzureadList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigAzureadObservation) DeepCopyInto(out *AuthConfigAzureadObservation) {
	*out = *in
	if in.AccessMode != nil {
		in, out := &in.AccessMode, &out.AccessMode
		*out = new(string)
		**out = **in
	}
	if in.AllowedPrincipalIds != nil {
		in, out := &in.AllowedPrincipalIds, &out.AllowedPrincipalIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.AuthEndpoint != nil {
		in, out := &in.AuthEndpoint, &out.AuthEndpoint
		*out = new(string)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.Endpoint != nil {
		in, out := &in.Endpoint, &out.Endpoint
		*out = new(string)
		**out = **in
	}
	if in.GraphEndpoint != nil {
		in, out := &in.GraphEndpoint, &out.GraphEndpoint
		*out = new(string)
		**out = **in
	}
	if in.GroupMembershipFilter != nil {
		in, out := &in.GroupMembershipFilter, &out.GroupMembershipFilter
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.RancherURL != nil {
		in, out := &in.RancherURL, &out.RancherURL
		*out = new(string)
		**out = **in
	}
	if in.TenantID != nil {
		in, out := &in.TenantID, &out.TenantID
		*out = new(string)
		**out = **in
	}
	if in.TokenEndpoint != nil {
		in, out := &in.TokenEndpoint, &out.TokenEndpoint
		*out = new(string)
		**out = **in
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigAzureadObservation.
func (in *AuthConfigAzureadObservation) DeepCopy() *AuthConfigAzureadObservation {
	if in == nil {
		return nil
	}
	out := new(AuthConfigAzureadObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigAzureadParameters) DeepCopyInto(out *AuthConfigAzureadParameters) {
	*out = *in
	if in.AccessMode != nil {
		in, out := &in.AccessMode, &out.AccessMode
		*out = new(string)
		**out = **in
	}
	if in.AllowedPrincipalIds != nil {
		in, out := &in.AllowedPrincipalIds, &out.AllowedPrincipalIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	in.ApplicationIDSecretRef.DeepCopyInto(&out.ApplicationIDSecretRef)
	in.ApplicationSecretSecretRef.DeepCopyInto(&out.ApplicationSecretSecretRef)
	if in.AuthEndpoint != nil {
		in, out := &in.AuthEndpoint, &out.AuthEndpoint
		*out = new(string)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.Endpoint != nil {
		in, out := &in.Endpoint, &out.Endpoint
		*out = new(string)
		**out = **in
	}
	if in.GraphEndpoint != nil {
		in, out := &in.GraphEndpoint, &out.GraphEndpoint
		*out = new(string)
		**out = **in
	}
	if in.GroupMembershipFilter != nil {
		in, out := &in.GroupMembershipFilter, &out.GroupMembershipFilter
		*out = new(string)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.RancherURL != nil {
		in, out := &in.RancherURL, &out.RancherURL
		*out = new(string)
		**out = **in
	}
	if in.TenantID != nil {
		in, out := &in.TenantID, &out.TenantID
		*out = new(string)
		**out = **in
	}
	if in.TokenEndpoint != nil {
		in, out := &in.TokenEndpoint, &out.TokenEndpoint
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigAzureadParameters.
func (in *AuthConfigAzureadParameters) DeepCopy() *AuthConfigAzureadParameters {
	if in == nil {
		return nil
	}
	out := new(AuthConfigAzureadParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigAzureadSpec) DeepCopyInto(out *AuthConfigAzureadSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigAzureadSpec.
func (in *AuthConfigAzureadSpec) DeepCopy() *AuthConfigAzureadSpec {
	if in == nil {
		return nil
	}
	out := new(AuthConfigAzureadSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigAzureadStatus) DeepCopyInto(out *AuthConfigAzureadStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigAzureadStatus.
func (in *AuthConfigAzureadStatus) DeepCopy() *AuthConfigAzureadStatus {
	if in == nil {
		return nil
	}
	out := new(AuthConfigAzureadStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigFreeipa) DeepCopyInto(out *AuthConfigFreeipa) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigFreeipa.
func (in *AuthConfigFreeipa) DeepCopy() *AuthConfigFreeipa {
	if in == nil {
		return nil
	}
	out := new(AuthConfigFreeipa)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AuthConfigFreeipa) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigFreeipaInitParameters) DeepCopyInto(out *AuthConfigFreeipaInitParameters) {
	*out = *in
	if in.AccessMode != nil {
		in, out := &in.AccessMode, &out.AccessMode
		*out = new(string)
		**out = **in
	}
	if in.AllowedPrincipalIds != nil {
		in, out := &in.AllowedPrincipalIds, &out.AllowedPrincipalIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.CertificateSecretRef != nil {
		in, out := &in.CertificateSecretRef, &out.CertificateSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.ConnectionTimeout != nil {
		in, out := &in.ConnectionTimeout, &out.ConnectionTimeout
		*out = new(float64)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.GroupDnAttribute != nil {
		in, out := &in.GroupDnAttribute, &out.GroupDnAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupMemberMappingAttribute != nil {
		in, out := &in.GroupMemberMappingAttribute, &out.GroupMemberMappingAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupMemberUserAttribute != nil {
		in, out := &in.GroupMemberUserAttribute, &out.GroupMemberUserAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupNameAttribute != nil {
		in, out := &in.GroupNameAttribute, &out.GroupNameAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupObjectClass != nil {
		in, out := &in.GroupObjectClass, &out.GroupObjectClass
		*out = new(string)
		**out = **in
	}
	if in.GroupSearchAttribute != nil {
		in, out := &in.GroupSearchAttribute, &out.GroupSearchAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupSearchBase != nil {
		in, out := &in.GroupSearchBase, &out.GroupSearchBase
		*out = new(string)
		**out = **in
	}
	if in.GroupSearchFilter != nil {
		in, out := &in.GroupSearchFilter, &out.GroupSearchFilter
		*out = new(string)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.NestedGroupMembershipEnabled != nil {
		in, out := &in.NestedGroupMembershipEnabled, &out.NestedGroupMembershipEnabled
		*out = new(bool)
		**out = **in
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(float64)
		**out = **in
	}
	if in.Servers != nil {
		in, out := &in.Servers, &out.Servers
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	in.ServiceAccountDistinguishedNameSecretRef.DeepCopyInto(&out.ServiceAccountDistinguishedNameSecretRef)
	in.ServiceAccountPasswordSecretRef.DeepCopyInto(&out.ServiceAccountPasswordSecretRef)
	if in.StartTLS != nil {
		in, out := &in.StartTLS, &out.StartTLS
		*out = new(bool)
		**out = **in
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(bool)
		**out = **in
	}
	in.TestPasswordSecretRef.DeepCopyInto(&out.TestPasswordSecretRef)
	if in.TestUsername != nil {
		in, out := &in.TestUsername, &out.TestUsername
		*out = new(string)
		**out = **in
	}
	if in.UserDisabledBitMask != nil {
		in, out := &in.UserDisabledBitMask, &out.UserDisabledBitMask
		*out = new(float64)
		**out = **in
	}
	if in.UserEnabledAttribute != nil {
		in, out := &in.UserEnabledAttribute, &out.UserEnabledAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserLoginAttribute != nil {
		in, out := &in.UserLoginAttribute, &out.UserLoginAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserMemberAttribute != nil {
		in, out := &in.UserMemberAttribute, &out.UserMemberAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserNameAttribute != nil {
		in, out := &in.UserNameAttribute, &out.UserNameAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserObjectClass != nil {
		in, out := &in.UserObjectClass, &out.UserObjectClass
		*out = new(string)
		**out = **in
	}
	if in.UserSearchAttribute != nil {
		in, out := &in.UserSearchAttribute, &out.UserSearchAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserSearchBase != nil {
		in, out := &in.UserSearchBase, &out.UserSearchBase
		*out = new(string)
		**out = **in
	}
	if in.UserSearchFilter != nil {
		in, out := &in.UserSearchFilter, &out.UserSearchFilter
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigFreeipaInitParameters.
func (in *AuthConfigFreeipaInitParameters) DeepCopy() *AuthConfigFreeipaInitParameters {
	if in == nil {
		return nil
	}
	out := new(AuthConfigFreeipaInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigFreeipaList) DeepCopyInto(out *AuthConfigFreeipaList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]AuthConfigFreeipa, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigFreeipaList.
func (in *AuthConfigFreeipaList) DeepCopy() *AuthConfigFreeipaList {
	if in == nil {
		return nil
	}
	out := new(AuthConfigFreeipaList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AuthConfigFreeipaList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigFreeipaObservation) DeepCopyInto(out *AuthConfigFreeipaObservation) {
	*out = *in
	if in.AccessMode != nil {
		in, out := &in.AccessMode, &out.AccessMode
		*out = new(string)
		**out = **in
	}
	if in.AllowedPrincipalIds != nil {
		in, out := &in.AllowedPrincipalIds, &out.AllowedPrincipalIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.ConnectionTimeout != nil {
		in, out := &in.ConnectionTimeout, &out.ConnectionTimeout
		*out = new(float64)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.GroupDnAttribute != nil {
		in, out := &in.GroupDnAttribute, &out.GroupDnAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupMemberMappingAttribute != nil {
		in, out := &in.GroupMemberMappingAttribute, &out.GroupMemberMappingAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupMemberUserAttribute != nil {
		in, out := &in.GroupMemberUserAttribute, &out.GroupMemberUserAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupNameAttribute != nil {
		in, out := &in.GroupNameAttribute, &out.GroupNameAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupObjectClass != nil {
		in, out := &in.GroupObjectClass, &out.GroupObjectClass
		*out = new(string)
		**out = **in
	}
	if in.GroupSearchAttribute != nil {
		in, out := &in.GroupSearchAttribute, &out.GroupSearchAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupSearchBase != nil {
		in, out := &in.GroupSearchBase, &out.GroupSearchBase
		*out = new(string)
		**out = **in
	}
	if in.GroupSearchFilter != nil {
		in, out := &in.GroupSearchFilter, &out.GroupSearchFilter
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.NestedGroupMembershipEnabled != nil {
		in, out := &in.NestedGroupMembershipEnabled, &out.NestedGroupMembershipEnabled
		*out = new(bool)
		**out = **in
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(float64)
		**out = **in
	}
	if in.Servers != nil {
		in, out := &in.Servers, &out.Servers
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.StartTLS != nil {
		in, out := &in.StartTLS, &out.StartTLS
		*out = new(bool)
		**out = **in
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(bool)
		**out = **in
	}
	if in.TestUsername != nil {
		in, out := &in.TestUsername, &out.TestUsername
		*out = new(string)
		**out = **in
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
	if in.UserDisabledBitMask != nil {
		in, out := &in.UserDisabledBitMask, &out.UserDisabledBitMask
		*out = new(float64)
		**out = **in
	}
	if in.UserEnabledAttribute != nil {
		in, out := &in.UserEnabledAttribute, &out.UserEnabledAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserLoginAttribute != nil {
		in, out := &in.UserLoginAttribute, &out.UserLoginAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserMemberAttribute != nil {
		in, out := &in.UserMemberAttribute, &out.UserMemberAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserNameAttribute != nil {
		in, out := &in.UserNameAttribute, &out.UserNameAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserObjectClass != nil {
		in, out := &in.UserObjectClass, &out.UserObjectClass
		*out = new(string)
		**out = **in
	}
	if in.UserSearchAttribute != nil {
		in, out := &in.UserSearchAttribute, &out.UserSearchAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserSearchBase != nil {
		in, out := &in.UserSearchBase, &out.UserSearchBase
		*out = new(string)
		**out = **in
	}
	if in.UserSearchFilter != nil {
		in, out := &in.UserSearchFilter, &out.UserSearchFilter
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigFreeipaObservation.
func (in *AuthConfigFreeipaObservation) DeepCopy() *AuthConfigFreeipaObservation {
	if in == nil {
		return nil
	}
	out := new(AuthConfigFreeipaObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigFreeipaParameters) DeepCopyInto(out *AuthConfigFreeipaParameters) {
	*out = *in
	if in.AccessMode != nil {
		in, out := &in.AccessMode, &out.AccessMode
		*out = new(string)
		**out = **in
	}
	if in.AllowedPrincipalIds != nil {
		in, out := &in.AllowedPrincipalIds, &out.AllowedPrincipalIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.CertificateSecretRef != nil {
		in, out := &in.CertificateSecretRef, &out.CertificateSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.ConnectionTimeout != nil {
		in, out := &in.ConnectionTimeout, &out.ConnectionTimeout
		*out = new(float64)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.GroupDnAttribute != nil {
		in, out := &in.GroupDnAttribute, &out.GroupDnAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupMemberMappingAttribute != nil {
		in, out := &in.GroupMemberMappingAttribute, &out.GroupMemberMappingAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupMemberUserAttribute != nil {
		in, out := &in.GroupMemberUserAttribute, &out.GroupMemberUserAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupNameAttribute != nil {
		in, out := &in.GroupNameAttribute, &out.GroupNameAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupObjectClass != nil {
		in, out := &in.GroupObjectClass, &out.GroupObjectClass
		*out = new(string)
		**out = **in
	}
	if in.GroupSearchAttribute != nil {
		in, out := &in.GroupSearchAttribute, &out.GroupSearchAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupSearchBase != nil {
		in, out := &in.GroupSearchBase, &out.GroupSearchBase
		*out = new(string)
		**out = **in
	}
	if in.GroupSearchFilter != nil {
		in, out := &in.GroupSearchFilter, &out.GroupSearchFilter
		*out = new(string)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.NestedGroupMembershipEnabled != nil {
		in, out := &in.NestedGroupMembershipEnabled, &out.NestedGroupMembershipEnabled
		*out = new(bool)
		**out = **in
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(float64)
		**out = **in
	}
	if in.Servers != nil {
		in, out := &in.Servers, &out.Servers
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	in.ServiceAccountDistinguishedNameSecretRef.DeepCopyInto(&out.ServiceAccountDistinguishedNameSecretRef)
	in.ServiceAccountPasswordSecretRef.DeepCopyInto(&out.ServiceAccountPasswordSecretRef)
	if in.StartTLS != nil {
		in, out := &in.StartTLS, &out.StartTLS
		*out = new(bool)
		**out = **in
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(bool)
		**out = **in
	}
	in.TestPasswordSecretRef.DeepCopyInto(&out.TestPasswordSecretRef)
	if in.TestUsername != nil {
		in, out := &in.TestUsername, &out.TestUsername
		*out = new(string)
		**out = **in
	}
	if in.UserDisabledBitMask != nil {
		in, out := &in.UserDisabledBitMask, &out.UserDisabledBitMask
		*out = new(float64)
		**out = **in
	}
	if in.UserEnabledAttribute != nil {
		in, out := &in.UserEnabledAttribute, &out.UserEnabledAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserLoginAttribute != nil {
		in, out := &in.UserLoginAttribute, &out.UserLoginAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserMemberAttribute != nil {
		in, out := &in.UserMemberAttribute, &out.UserMemberAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserNameAttribute != nil {
		in, out := &in.UserNameAttribute, &out.UserNameAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserObjectClass != nil {
		in, out := &in.UserObjectClass, &out.UserObjectClass
		*out = new(string)
		**out = **in
	}
	if in.UserSearchAttribute != nil {
		in, out := &in.UserSearchAttribute, &out.UserSearchAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserSearchBase != nil {
		in, out := &in.UserSearchBase, &out.UserSearchBase
		*out = new(string)
		**out = **in
	}
	if in.UserSearchFilter != nil {
		in, out := &in.UserSearchFilter, &out.UserSearchFilter
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigFreeipaParameters.
func (in *AuthConfigFreeipaParameters) DeepCopy() *AuthConfigFreeipaParameters {
	if in == nil {
		return nil
	}
	out := new(AuthConfigFreeipaParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigFreeipaSpec) DeepCopyInto(out *AuthConfigFreeipaSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigFreeipaSpec.
func (in *AuthConfigFreeipaSpec) DeepCopy() *AuthConfigFreeipaSpec {
	if in == nil {
		return nil
	}
	out := new(AuthConfigFreeipaSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigFreeipaStatus) DeepCopyInto(out *AuthConfigFreeipaStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigFreeipaStatus.
func (in *AuthConfigFreeipaStatus) DeepCopy() *AuthConfigFreeipaStatus {
	if in == nil {
		return nil
	}
	out := new(AuthConfigFreeipaStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigGithub) DeepCopyInto(out *AuthConfigGithub) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigGithub.
func (in *AuthConfigGithub) DeepCopy() *AuthConfigGithub {
	if in == nil {
		return nil
	}
	out := new(AuthConfigGithub)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AuthConfigGithub) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigGithubInitParameters) DeepCopyInto(out *AuthConfigGithubInitParameters) {
	*out = *in
	if in.AccessMode != nil {
		in, out := &in.AccessMode, &out.AccessMode
		*out = new(string)
		**out = **in
	}
	if in.AllowedPrincipalIds != nil {
		in, out := &in.AllowedPrincipalIds, &out.AllowedPrincipalIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	in.ClientIDSecretRef.DeepCopyInto(&out.ClientIDSecretRef)
	in.ClientSecretSecretRef.DeepCopyInto(&out.ClientSecretSecretRef)
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.Hostname != nil {
		in, out := &in.Hostname, &out.Hostname
		*out = new(string)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigGithubInitParameters.
func (in *AuthConfigGithubInitParameters) DeepCopy() *AuthConfigGithubInitParameters {
	if in == nil {
		return nil
	}
	out := new(AuthConfigGithubInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigGithubList) DeepCopyInto(out *AuthConfigGithubList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]AuthConfigGithub, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigGithubList.
func (in *AuthConfigGithubList) DeepCopy() *AuthConfigGithubList {
	if in == nil {
		return nil
	}
	out := new(AuthConfigGithubList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AuthConfigGithubList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigGithubObservation) DeepCopyInto(out *AuthConfigGithubObservation) {
	*out = *in
	if in.AccessMode != nil {
		in, out := &in.AccessMode, &out.AccessMode
		*out = new(string)
		**out = **in
	}
	if in.AllowedPrincipalIds != nil {
		in, out := &in.AllowedPrincipalIds, &out.AllowedPrincipalIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.Hostname != nil {
		in, out := &in.Hostname, &out.Hostname
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(bool)
		**out = **in
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigGithubObservation.
func (in *AuthConfigGithubObservation) DeepCopy() *AuthConfigGithubObservation {
	if in == nil {
		return nil
	}
	out := new(AuthConfigGithubObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigGithubParameters) DeepCopyInto(out *AuthConfigGithubParameters) {
	*out = *in
	if in.AccessMode != nil {
		in, out := &in.AccessMode, &out.AccessMode
		*out = new(string)
		**out = **in
	}
	if in.AllowedPrincipalIds != nil {
		in, out := &in.AllowedPrincipalIds, &out.AllowedPrincipalIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	in.ClientIDSecretRef.DeepCopyInto(&out.ClientIDSecretRef)
	in.ClientSecretSecretRef.DeepCopyInto(&out.ClientSecretSecretRef)
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.Hostname != nil {
		in, out := &in.Hostname, &out.Hostname
		*out = new(string)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigGithubParameters.
func (in *AuthConfigGithubParameters) DeepCopy() *AuthConfigGithubParameters {
	if in == nil {
		return nil
	}
	out := new(AuthConfigGithubParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigGithubSpec) DeepCopyInto(out *AuthConfigGithubSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigGithubSpec.
func (in *AuthConfigGithubSpec) DeepCopy() *AuthConfigGithubSpec {
	if in == nil {
		return nil
	}
	out := new(AuthConfigGithubSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigGithubStatus) DeepCopyInto(out *AuthConfigGithubStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigGithubStatus.
func (in *AuthConfigGithubStatus) DeepCopy() *AuthConfigGithubStatus {
	if in == nil {
		return nil
	}
	out := new(AuthConfigGithubStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigKeycloak) DeepCopyInto(out *AuthConfigKeycloak) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigKeycloak.
func (in *AuthConfigKeycloak) DeepCopy() *AuthConfigKeycloak {
	if in == nil {
		return nil
	}
	out := new(AuthConfigKeycloak)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AuthConfigKeycloak) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigKeycloakInitParameters) DeepCopyInto(out *AuthConfigKeycloakInitParameters) {
	*out = *in
	if in.AccessMode != nil {
		in, out := &in.AccessMode, &out.AccessMode
		*out = new(string)
		**out = **in
	}
	if in.AllowedPrincipalIds != nil {
		in, out := &in.AllowedPrincipalIds, &out.AllowedPrincipalIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DisplayNameField != nil {
		in, out := &in.DisplayNameField, &out.DisplayNameField
		*out = new(string)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.EntityID != nil {
		in, out := &in.EntityID, &out.EntityID
		*out = new(string)
		**out = **in
	}
	if in.GroupsField != nil {
		in, out := &in.GroupsField, &out.GroupsField
		*out = new(string)
		**out = **in
	}
	in.IdpMetadataContentSecretRef.DeepCopyInto(&out.IdpMetadataContentSecretRef)
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.RancherAPIHost != nil {
		in, out := &in.RancherAPIHost, &out.RancherAPIHost
		*out = new(string)
		**out = **in
	}
	in.SpCertSecretRef.DeepCopyInto(&out.SpCertSecretRef)
	in.SpKeySecretRef.DeepCopyInto(&out.SpKeySecretRef)
	if in.UIDField != nil {
		in, out := &in.UIDField, &out.UIDField
		*out = new(string)
		**out = **in
	}
	if in.UserNameField != nil {
		in, out := &in.UserNameField, &out.UserNameField
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigKeycloakInitParameters.
func (in *AuthConfigKeycloakInitParameters) DeepCopy() *AuthConfigKeycloakInitParameters {
	if in == nil {
		return nil
	}
	out := new(AuthConfigKeycloakInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigKeycloakList) DeepCopyInto(out *AuthConfigKeycloakList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]AuthConfigKeycloak, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigKeycloakList.
func (in *AuthConfigKeycloakList) DeepCopy() *AuthConfigKeycloakList {
	if in == nil {
		return nil
	}
	out := new(AuthConfigKeycloakList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AuthConfigKeycloakList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigKeycloakObservation) DeepCopyInto(out *AuthConfigKeycloakObservation) {
	*out = *in
	if in.AccessMode != nil {
		in, out := &in.AccessMode, &out.AccessMode
		*out = new(string)
		**out = **in
	}
	if in.AllowedPrincipalIds != nil {
		in, out := &in.AllowedPrincipalIds, &out.AllowedPrincipalIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DisplayNameField != nil {
		in, out := &in.DisplayNameField, &out.DisplayNameField
		*out = new(string)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.EntityID != nil {
		in, out := &in.EntityID, &out.EntityID
		*out = new(string)
		**out = **in
	}
	if in.GroupsField != nil {
		in, out := &in.GroupsField, &out.GroupsField
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.RancherAPIHost != nil {
		in, out := &in.RancherAPIHost, &out.RancherAPIHost
		*out = new(string)
		**out = **in
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
	if in.UIDField != nil {
		in, out := &in.UIDField, &out.UIDField
		*out = new(string)
		**out = **in
	}
	if in.UserNameField != nil {
		in, out := &in.UserNameField, &out.UserNameField
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigKeycloakObservation.
func (in *AuthConfigKeycloakObservation) DeepCopy() *AuthConfigKeycloakObservation {
	if in == nil {
		return nil
	}
	out := new(AuthConfigKeycloakObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigKeycloakParameters) DeepCopyInto(out *AuthConfigKeycloakParameters) {
	*out = *in
	if in.AccessMode != nil {
		in, out := &in.AccessMode, &out.AccessMode
		*out = new(string)
		**out = **in
	}
	if in.AllowedPrincipalIds != nil {
		in, out := &in.AllowedPrincipalIds, &out.AllowedPrincipalIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DisplayNameField != nil {
		in, out := &in.DisplayNameField, &out.DisplayNameField
		*out = new(string)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.EntityID != nil {
		in, out := &in.EntityID, &out.EntityID
		*out = new(string)
		**out = **in
	}
	if in.GroupsField != nil {
		in, out := &in.GroupsField, &out.GroupsField
		*out = new(string)
		**out = **in
	}
	in.IdpMetadataContentSecretRef.DeepCopyInto(&out.IdpMetadataContentSecretRef)
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.RancherAPIHost != nil {
		in, out := &in.RancherAPIHost, &out.RancherAPIHost
		*out = new(string)
		**out = **in
	}
	in.SpCertSecretRef.DeepCopyInto(&out.SpCertSecretRef)
	in.SpKeySecretRef.DeepCopyInto(&out.SpKeySecretRef)
	if in.UIDField != nil {
		in, out := &in.UIDField, &out.UIDField
		*out = new(string)
		**out = **in
	}
	if in.UserNameField != nil {
		in, out := &in.UserNameField, &out.UserNameField
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigKeycloakParameters.
func (in *AuthConfigKeycloakParameters) DeepCopy() *AuthConfigKeycloakParameters {
	if in == nil {
		return nil
	}
	out := new(AuthConfigKeycloakParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigKeycloakSpec) DeepCopyInto(out *AuthConfigKeycloakSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigKeycloakSpec.
func (in *AuthConfigKeycloakSpec) DeepCopy() *AuthConfigKeycloakSpec {
	if in == nil {
		return nil
	}
	out := new(AuthConfigKeycloakSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigKeycloakStatus) DeepCopyInto(out *AuthConfigKeycloakStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigKeycloakStatus.
func (in *AuthConfigKeycloakStatus) DeepCopy() *AuthConfigKeycloakStatus {
	if in == nil {
		return nil
	}
	out := new(AuthConfigKeycloakStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigOkta) DeepCopyInto(out *AuthConfigOkta) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigOkta.
func (in *AuthConfigOkta) DeepCopy() *AuthConfigOkta {
	if in == nil {
		return nil
	}
	out := new(AuthConfigOkta)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AuthConfigOkta) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigOktaInitParameters) DeepCopyInto(out *AuthConfigOktaInitParameters) {
	*out = *in
	if in.AccessMode != nil {
		in, out := &in.AccessMode, &out.AccessMode
		*out = new(string)
		**out = **in
	}
	if in.AllowedPrincipalIds != nil {
		in, out := &in.AllowedPrincipalIds, &out.AllowedPrincipalIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DisplayNameField != nil {
		in, out := &in.DisplayNameField, &out.DisplayNameField
		*out = new(string)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.GroupsField != nil {
		in, out := &in.GroupsField, &out.GroupsField
		*out = new(string)
		**out = **in
	}
	in.IdpMetadataContentSecretRef.DeepCopyInto(&out.IdpMetadataContentSecretRef)
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.RancherAPIHost != nil {
		in, out := &in.RancherAPIHost, &out.RancherAPIHost
		*out = new(string)
		**out = **in
	}
	in.SpCertSecretRef.DeepCopyInto(&out.SpCertSecretRef)
	in.SpKeySecretRef.DeepCopyInto(&out.SpKeySecretRef)
	if in.UIDField != nil {
		in, out := &in.UIDField, &out.UIDField
		*out = new(string)
		**out = **in
	}
	if in.UserNameField != nil {
		in, out := &in.UserNameField, &out.UserNameField
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigOktaInitParameters.
func (in *AuthConfigOktaInitParameters) DeepCopy() *AuthConfigOktaInitParameters {
	if in == nil {
		return nil
	}
	out := new(AuthConfigOktaInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigOktaList) DeepCopyInto(out *AuthConfigOktaList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]AuthConfigOkta, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigOktaList.
func (in *AuthConfigOktaList) DeepCopy() *AuthConfigOktaList {
	if in == nil {
		return nil
	}
	out := new(AuthConfigOktaList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AuthConfigOktaList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigOktaObservation) DeepCopyInto(out *AuthConfigOktaObservation) {
	*out = *in
	if in.AccessMode != nil {
		in, out := &in.AccessMode, &out.AccessMode
		*out = new(string)
		**out = **in
	}
	if in.AllowedPrincipalIds != nil {
		in, out := &in.AllowedPrincipalIds, &out.AllowedPrincipalIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DisplayNameField != nil {
		in, out := &in.DisplayNameField, &out.DisplayNameField
		*out = new(string)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.GroupsField != nil {
		in, out := &in.GroupsField, &out.GroupsField
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.RancherAPIHost != nil {
		in, out := &in.RancherAPIHost, &out.RancherAPIHost
		*out = new(string)
		**out = **in
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
	if in.UIDField != nil {
		in, out := &in.UIDField, &out.UIDField
		*out = new(string)
		**out = **in
	}
	if in.UserNameField != nil {
		in, out := &in.UserNameField, &out.UserNameField
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigOktaObservation.
func (in *AuthConfigOktaObservation) DeepCopy() *AuthConfigOktaObservation {
	if in == nil {
		return nil
	}
	out := new(AuthConfigOktaObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigOktaParameters) DeepCopyInto(out *AuthConfigOktaParameters) {
	*out = *in
	if in.AccessMode != nil {
		in, out := &in.AccessMode, &out.AccessMode
		*out = new(string)
		**out = **in
	}
	if in.AllowedPrincipalIds != nil {
		in, out := &in.AllowedPrincipalIds, &out.AllowedPrincipalIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DisplayNameField != nil {
		in, out := &in.DisplayNameField, &out.DisplayNameField
		*out = new(string)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.GroupsField != nil {
		in, out := &in.GroupsField, &out.GroupsField
		*out = new(string)
		**out = **in
	}
	in.IdpMetadataContentSecretRef.DeepCopyInto(&out.IdpMetadataContentSecretRef)
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.RancherAPIHost != nil {
		in, out := &in.RancherAPIHost, &out.RancherAPIHost
		*out = new(string)
		**out = **in
	}
	in.SpCertSecretRef.DeepCopyInto(&out.SpCertSecretRef)
	in.SpKeySecretRef.DeepCopyInto(&out.SpKeySecretRef)
	if in.UIDField != nil {
		in, out := &in.UIDField, &out.UIDField
		*out = new(string)
		**out = **in
	}
	if in.UserNameField != nil {
		in, out := &in.UserNameField, &out.UserNameField
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigOktaParameters.
func (in *AuthConfigOktaParameters) DeepCopy() *AuthConfigOktaParameters {
	if in == nil {
		return nil
	}
	out := new(AuthConfigOktaParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigOktaSpec) DeepCopyInto(out *AuthConfigOktaSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigOktaSpec.
func (in *AuthConfigOktaSpec) DeepCopy() *AuthConfigOktaSpec {
	if in == nil {
		return nil
	}
	out := new(AuthConfigOktaSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigOktaStatus) DeepCopyInto(out *AuthConfigOktaStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigOktaStatus.
func (in *AuthConfigOktaStatus) DeepCopy() *AuthConfigOktaStatus {
	if in == nil {
		return nil
	}
	out := new(AuthConfigOktaStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigOpenldap) DeepCopyInto(out *AuthConfigOpenldap) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigOpenldap.
func (in *AuthConfigOpenldap) DeepCopy() *AuthConfigOpenldap {
	if in == nil {
		return nil
	}
	out := new(AuthConfigOpenldap)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AuthConfigOpenldap) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigOpenldapInitParameters) DeepCopyInto(out *AuthConfigOpenldapInitParameters) {
	*out = *in
	if in.AccessMode != nil {
		in, out := &in.AccessMode, &out.AccessMode
		*out = new(string)
		**out = **in
	}
	if in.AllowedPrincipalIds != nil {
		in, out := &in.AllowedPrincipalIds, &out.AllowedPrincipalIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.CertificateSecretRef != nil {
		in, out := &in.CertificateSecretRef, &out.CertificateSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.ConnectionTimeout != nil {
		in, out := &in.ConnectionTimeout, &out.ConnectionTimeout
		*out = new(float64)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.GroupDnAttribute != nil {
		in, out := &in.GroupDnAttribute, &out.GroupDnAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupMemberMappingAttribute != nil {
		in, out := &in.GroupMemberMappingAttribute, &out.GroupMemberMappingAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupMemberUserAttribute != nil {
		in, out := &in.GroupMemberUserAttribute, &out.GroupMemberUserAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupNameAttribute != nil {
		in, out := &in.GroupNameAttribute, &out.GroupNameAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupObjectClass != nil {
		in, out := &in.GroupObjectClass, &out.GroupObjectClass
		*out = new(string)
		**out = **in
	}
	if in.GroupSearchAttribute != nil {
		in, out := &in.GroupSearchAttribute, &out.GroupSearchAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupSearchBase != nil {
		in, out := &in.GroupSearchBase, &out.GroupSearchBase
		*out = new(string)
		**out = **in
	}
	if in.GroupSearchFilter != nil {
		in, out := &in.GroupSearchFilter, &out.GroupSearchFilter
		*out = new(string)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.NestedGroupMembershipEnabled != nil {
		in, out := &in.NestedGroupMembershipEnabled, &out.NestedGroupMembershipEnabled
		*out = new(bool)
		**out = **in
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(float64)
		**out = **in
	}
	if in.Servers != nil {
		in, out := &in.Servers, &out.Servers
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	in.ServiceAccountDistinguishedNameSecretRef.DeepCopyInto(&out.ServiceAccountDistinguishedNameSecretRef)
	in.ServiceAccountPasswordSecretRef.DeepCopyInto(&out.ServiceAccountPasswordSecretRef)
	if in.StartTLS != nil {
		in, out := &in.StartTLS, &out.StartTLS
		*out = new(bool)
		**out = **in
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(bool)
		**out = **in
	}
	in.TestPasswordSecretRef.DeepCopyInto(&out.TestPasswordSecretRef)
	if in.TestUsername != nil {
		in, out := &in.TestUsername, &out.TestUsername
		*out = new(string)
		**out = **in
	}
	if in.UserDisabledBitMask != nil {
		in, out := &in.UserDisabledBitMask, &out.UserDisabledBitMask
		*out = new(float64)
		**out = **in
	}
	if in.UserEnabledAttribute != nil {
		in, out := &in.UserEnabledAttribute, &out.UserEnabledAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserLoginAttribute != nil {
		in, out := &in.UserLoginAttribute, &out.UserLoginAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserMemberAttribute != nil {
		in, out := &in.UserMemberAttribute, &out.UserMemberAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserNameAttribute != nil {
		in, out := &in.UserNameAttribute, &out.UserNameAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserObjectClass != nil {
		in, out := &in.UserObjectClass, &out.UserObjectClass
		*out = new(string)
		**out = **in
	}
	if in.UserSearchAttribute != nil {
		in, out := &in.UserSearchAttribute, &out.UserSearchAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserSearchBase != nil {
		in, out := &in.UserSearchBase, &out.UserSearchBase
		*out = new(string)
		**out = **in
	}
	if in.UserSearchFilter != nil {
		in, out := &in.UserSearchFilter, &out.UserSearchFilter
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigOpenldapInitParameters.
func (in *AuthConfigOpenldapInitParameters) DeepCopy() *AuthConfigOpenldapInitParameters {
	if in == nil {
		return nil
	}
	out := new(AuthConfigOpenldapInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigOpenldapList) DeepCopyInto(out *AuthConfigOpenldapList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]AuthConfigOpenldap, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigOpenldapList.
func (in *AuthConfigOpenldapList) DeepCopy() *AuthConfigOpenldapList {
	if in == nil {
		return nil
	}
	out := new(AuthConfigOpenldapList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AuthConfigOpenldapList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigOpenldapObservation) DeepCopyInto(out *AuthConfigOpenldapObservation) {
	*out = *in
	if in.AccessMode != nil {
		in, out := &in.AccessMode, &out.AccessMode
		*out = new(string)
		**out = **in
	}
	if in.AllowedPrincipalIds != nil {
		in, out := &in.AllowedPrincipalIds, &out.AllowedPrincipalIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.ConnectionTimeout != nil {
		in, out := &in.ConnectionTimeout, &out.ConnectionTimeout
		*out = new(float64)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.GroupDnAttribute != nil {
		in, out := &in.GroupDnAttribute, &out.GroupDnAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupMemberMappingAttribute != nil {
		in, out := &in.GroupMemberMappingAttribute, &out.GroupMemberMappingAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupMemberUserAttribute != nil {
		in, out := &in.GroupMemberUserAttribute, &out.GroupMemberUserAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupNameAttribute != nil {
		in, out := &in.GroupNameAttribute, &out.GroupNameAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupObjectClass != nil {
		in, out := &in.GroupObjectClass, &out.GroupObjectClass
		*out = new(string)
		**out = **in
	}
	if in.GroupSearchAttribute != nil {
		in, out := &in.GroupSearchAttribute, &out.GroupSearchAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupSearchBase != nil {
		in, out := &in.GroupSearchBase, &out.GroupSearchBase
		*out = new(string)
		**out = **in
	}
	if in.GroupSearchFilter != nil {
		in, out := &in.GroupSearchFilter, &out.GroupSearchFilter
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.NestedGroupMembershipEnabled != nil {
		in, out := &in.NestedGroupMembershipEnabled, &out.NestedGroupMembershipEnabled
		*out = new(bool)
		**out = **in
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(float64)
		**out = **in
	}
	if in.Servers != nil {
		in, out := &in.Servers, &out.Servers
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.StartTLS != nil {
		in, out := &in.StartTLS, &out.StartTLS
		*out = new(bool)
		**out = **in
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(bool)
		**out = **in
	}
	if in.TestUsername != nil {
		in, out := &in.TestUsername, &out.TestUsername
		*out = new(string)
		**out = **in
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
	if in.UserDisabledBitMask != nil {
		in, out := &in.UserDisabledBitMask, &out.UserDisabledBitMask
		*out = new(float64)
		**out = **in
	}
	if in.UserEnabledAttribute != nil {
		in, out := &in.UserEnabledAttribute, &out.UserEnabledAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserLoginAttribute != nil {
		in, out := &in.UserLoginAttribute, &out.UserLoginAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserMemberAttribute != nil {
		in, out := &in.UserMemberAttribute, &out.UserMemberAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserNameAttribute != nil {
		in, out := &in.UserNameAttribute, &out.UserNameAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserObjectClass != nil {
		in, out := &in.UserObjectClass, &out.UserObjectClass
		*out = new(string)
		**out = **in
	}
	if in.UserSearchAttribute != nil {
		in, out := &in.UserSearchAttribute, &out.UserSearchAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserSearchBase != nil {
		in, out := &in.UserSearchBase, &out.UserSearchBase
		*out = new(string)
		**out = **in
	}
	if in.UserSearchFilter != nil {
		in, out := &in.UserSearchFilter, &out.UserSearchFilter
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigOpenldapObservation.
func (in *AuthConfigOpenldapObservation) DeepCopy() *AuthConfigOpenldapObservation {
	if in == nil {
		return nil
	}
	out := new(AuthConfigOpenldapObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigOpenldapParameters) DeepCopyInto(out *AuthConfigOpenldapParameters) {
	*out = *in
	if in.AccessMode != nil {
		in, out := &in.AccessMode, &out.AccessMode
		*out = new(string)
		**out = **in
	}
	if in.AllowedPrincipalIds != nil {
		in, out := &in.AllowedPrincipalIds, &out.AllowedPrincipalIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.CertificateSecretRef != nil {
		in, out := &in.CertificateSecretRef, &out.CertificateSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.ConnectionTimeout != nil {
		in, out := &in.ConnectionTimeout, &out.ConnectionTimeout
		*out = new(float64)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.GroupDnAttribute != nil {
		in, out := &in.GroupDnAttribute, &out.GroupDnAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupMemberMappingAttribute != nil {
		in, out := &in.GroupMemberMappingAttribute, &out.GroupMemberMappingAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupMemberUserAttribute != nil {
		in, out := &in.GroupMemberUserAttribute, &out.GroupMemberUserAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupNameAttribute != nil {
		in, out := &in.GroupNameAttribute, &out.GroupNameAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupObjectClass != nil {
		in, out := &in.GroupObjectClass, &out.GroupObjectClass
		*out = new(string)
		**out = **in
	}
	if in.GroupSearchAttribute != nil {
		in, out := &in.GroupSearchAttribute, &out.GroupSearchAttribute
		*out = new(string)
		**out = **in
	}
	if in.GroupSearchBase != nil {
		in, out := &in.GroupSearchBase, &out.GroupSearchBase
		*out = new(string)
		**out = **in
	}
	if in.GroupSearchFilter != nil {
		in, out := &in.GroupSearchFilter, &out.GroupSearchFilter
		*out = new(string)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.NestedGroupMembershipEnabled != nil {
		in, out := &in.NestedGroupMembershipEnabled, &out.NestedGroupMembershipEnabled
		*out = new(bool)
		**out = **in
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(float64)
		**out = **in
	}
	if in.Servers != nil {
		in, out := &in.Servers, &out.Servers
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	in.ServiceAccountDistinguishedNameSecretRef.DeepCopyInto(&out.ServiceAccountDistinguishedNameSecretRef)
	in.ServiceAccountPasswordSecretRef.DeepCopyInto(&out.ServiceAccountPasswordSecretRef)
	if in.StartTLS != nil {
		in, out := &in.StartTLS, &out.StartTLS
		*out = new(bool)
		**out = **in
	}
	if in.TLS != nil {
		in, out := &in.TLS, &out.TLS
		*out = new(bool)
		**out = **in
	}
	in.TestPasswordSecretRef.DeepCopyInto(&out.TestPasswordSecretRef)
	if in.TestUsername != nil {
		in, out := &in.TestUsername, &out.TestUsername
		*out = new(string)
		**out = **in
	}
	if in.UserDisabledBitMask != nil {
		in, out := &in.UserDisabledBitMask, &out.UserDisabledBitMask
		*out = new(float64)
		**out = **in
	}
	if in.UserEnabledAttribute != nil {
		in, out := &in.UserEnabledAttribute, &out.UserEnabledAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserLoginAttribute != nil {
		in, out := &in.UserLoginAttribute, &out.UserLoginAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserMemberAttribute != nil {
		in, out := &in.UserMemberAttribute, &out.UserMemberAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserNameAttribute != nil {
		in, out := &in.UserNameAttribute, &out.UserNameAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserObjectClass != nil {
		in, out := &in.UserObjectClass, &out.UserObjectClass
		*out = new(string)
		**out = **in
	}
	if in.UserSearchAttribute != nil {
		in, out := &in.UserSearchAttribute, &out.UserSearchAttribute
		*out = new(string)
		**out = **in
	}
	if in.UserSearchBase != nil {
		in, out := &in.UserSearchBase, &out.UserSearchBase
		*out = new(string)
		**out = **in
	}
	if in.UserSearchFilter != nil {
		in, out := &in.UserSearchFilter, &out.UserSearchFilter
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigOpenldapParameters.
func (in *AuthConfigOpenldapParameters) DeepCopy() *AuthConfigOpenldapParameters {
	if in == nil {
		return nil
	}
	out := new(AuthConfigOpenldapParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigOpenldapSpec) DeepCopyInto(out *AuthConfigOpenldapSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigOpenldapSpec.
func (in *AuthConfigOpenldapSpec) DeepCopy() *AuthConfigOpenldapSpec {
	if in == nil {
		return nil
	}
	out := new(AuthConfigOpenldapSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigOpenldapStatus) DeepCopyInto(out *AuthConfigOpenldapStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigOpenldapStatus.
func (in *AuthConfigOpenldapStatus) DeepCopy() *AuthConfigOpenldapStatus {
	if in == nil {
		return nil
	}
	out := new(AuthConfigOpenldapStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigPing) DeepCopyInto(out *AuthConfigPing) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigPing.
func (in *AuthConfigPing) DeepCopy() *AuthConfigPing {
	if in == nil {
		return nil
	}
	out := new(AuthConfigPing)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AuthConfigPing) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigPingInitParameters) DeepCopyInto(out *AuthConfigPingInitParameters) {
	*out = *in
	if in.AccessMode != nil {
		in, out := &in.AccessMode, &out.AccessMode
		*out = new(string)
		**out = **in
	}
	if in.AllowedPrincipalIds != nil {
		in, out := &in.AllowedPrincipalIds, &out.AllowedPrincipalIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DisplayNameField != nil {
		in, out := &in.DisplayNameField, &out.DisplayNameField
		*out = new(string)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.EntityIDField != nil {
		in, out := &in.EntityIDField, &out.EntityIDField
		*out = new(string)
		**out = **in
	}
	if in.GroupsField != nil {
		in, out := &in.GroupsField, &out.GroupsField
		*out = new(string)
		**out = **in
	}
	in.IdpMetadataContentSecretRef.DeepCopyInto(&out.IdpMetadataContentSecretRef)
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.RancherAPIHost != nil {
		in, out := &in.RancherAPIHost, &out.RancherAPIHost
		*out = new(string)
		**out = **in
	}
	in.SpCertSecretRef.DeepCopyInto(&out.SpCertSecretRef)
	in.SpKeySecretRef.DeepCopyInto(&out.SpKeySecretRef)
	if in.UIDField != nil {
		in, out := &in.UIDField, &out.UIDField
		*out = new(string)
		**out = **in
	}
	if in.UserNameField != nil {
		in, out := &in.UserNameField, &out.UserNameField
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigPingInitParameters.
func (in *AuthConfigPingInitParameters) DeepCopy() *AuthConfigPingInitParameters {
	if in == nil {
		return nil
	}
	out := new(AuthConfigPingInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigPingList) DeepCopyInto(out *AuthConfigPingList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]AuthConfigPing, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigPingList.
func (in *AuthConfigPingList) DeepCopy() *AuthConfigPingList {
	if in == nil {
		return nil
	}
	out := new(AuthConfigPingList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AuthConfigPingList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigPingObservation) DeepCopyInto(out *AuthConfigPingObservation) {
	*out = *in
	if in.AccessMode != nil {
		in, out := &in.AccessMode, &out.AccessMode
		*out = new(string)
		**out = **in
	}
	if in.AllowedPrincipalIds != nil {
		in, out := &in.AllowedPrincipalIds, &out.AllowedPrincipalIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DisplayNameField != nil {
		in, out := &in.DisplayNameField, &out.DisplayNameField
		*out = new(string)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.EntityIDField != nil {
		in, out := &in.EntityIDField, &out.EntityIDField
		*out = new(string)
		**out = **in
	}
	if in.GroupsField != nil {
		in, out := &in.GroupsField, &out.GroupsField
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.RancherAPIHost != nil {
		in, out := &in.RancherAPIHost, &out.RancherAPIHost
		*out = new(string)
		**out = **in
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
	if in.UIDField != nil {
		in, out := &in.UIDField, &out.UIDField
		*out = new(string)
		**out = **in
	}
	if in.UserNameField != nil {
		in, out := &in.UserNameField, &out.UserNameField
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigPingObservation.
func (in *AuthConfigPingObservation) DeepCopy() *AuthConfigPingObservation {
	if in == nil {
		return nil
	}
	out := new(AuthConfigPingObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigPingParameters) DeepCopyInto(out *AuthConfigPingParameters) {
	*out = *in
	if in.AccessMode != nil {
		in, out := &in.AccessMode, &out.AccessMode
		*out = new(string)
		**out = **in
	}
	if in.AllowedPrincipalIds != nil {
		in, out := &in.AllowedPrincipalIds, &out.AllowedPrincipalIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.DisplayNameField != nil {
		in, out := &in.DisplayNameField, &out.DisplayNameField
		*out = new(string)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.EntityIDField != nil {
		in, out := &in.EntityIDField, &out.EntityIDField
		*out = new(string)
		**out = **in
	}
	if in.GroupsField != nil {
		in, out := &in.GroupsField, &out.GroupsField
		*out = new(string)
		**out = **in
	}
	in.IdpMetadataContentSecretRef.DeepCopyInto(&out.IdpMetadataContentSecretRef)
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.RancherAPIHost != nil {
		in, out := &in.RancherAPIHost, &out.RancherAPIHost
		*out = new(string)
		**out = **in
	}
	in.SpCertSecretRef.DeepCopyInto(&out.SpCertSecretRef)
	in.SpKeySecretRef.DeepCopyInto(&out.SpKeySecretRef)
	if in.UIDField != nil {
		in, out := &in.UIDField, &out.UIDField
		*out = new(string)
		**out = **in
	}
	if in.UserNameField != nil {
		in, out := &in.UserNameField, &out.UserNameField
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigPingParameters.
func (in *AuthConfigPingParameters) DeepCopy() *AuthConfigPingParameters {
	if in == nil {
		return nil
	}
	out := new(AuthConfigPingParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigPingSpec) DeepCopyInto(out *AuthConfigPingSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigPingSpec.
func (in *AuthConfigPingSpec) DeepCopy() *AuthConfigPingSpec {
	if in == nil {
		return nil
	}
	out := new(AuthConfigPingSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuthConfigPingStatus) DeepCopyInto(out *AuthConfigPingStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthConfigPingStatus.
func (in *AuthConfigPingStatus) DeepCopy() *AuthConfigPingStatus {
	if in == nil {
		return nil
	}
	out := new(AuthConfigPingStatus)
	in.DeepCopyInto(out)
	return out
}
